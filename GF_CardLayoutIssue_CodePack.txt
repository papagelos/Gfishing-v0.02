// GF Card Layout Issue – Code Pack

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\BackdropBinder.cs =====

using System;
using System.Collections.Generic;
using UnityEngine;

public class BackdropBinder : MonoBehaviour
{
    [Serializable]
    public class WatchRef
    {
        public GameObject root;        // the UI root you open/close
        public CanvasGroup canvasGroup; // optional; if null we only check activeSelf
    }

    [SerializeField] private List<WatchRef> watch = new();
    [SerializeField] private GameObject backdrop;   // assign UI_Backdrop
    [SerializeField] private bool sendToBack = true;

    bool last;

    void Awake()
    {
        if (backdrop && sendToBack) backdrop.transform.SetAsFirstSibling();
        if (backdrop) backdrop.SetActive(false);
    }

    void LateUpdate()
    {
        bool show = false;
        for (int i = 0; i < watch.Count; i++)
        {
            var w = watch[i];
            if (!w.root) continue;
            bool openByActive = w.root.activeInHierarchy;
            bool openByAlpha  = (!w.canvasGroup || w.canvasGroup.alpha > 0.001f);
            if (openByActive && openByAlpha) { show = true; break; }
        }

        if (backdrop && last != show)
        {
            backdrop.SetActive(show);
            last = show;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\BeepFishFX.cs =====

using System.Collections;
using UnityEngine;
using UnityEngine.UI;

namespace GalacticFishing.UI
{
    [RequireComponent(typeof(Image))]
    [AddComponentMenu("Galactic Fishing/UI/Beep Fish FX")]
    public sealed class BeepFishFX : MonoBehaviour
    {
        [Header("Placement")]
        [SerializeField] Vector2 anchoredOffset = Vector2.zero; // relative to screen center
        [SerializeField] bool useNativeSize = false;
        [Tooltip("Max on-screen pixels for the longest side (before Canvas scaling).")]
        [SerializeField] float maxPixels = 1024f;

        [Header("Fade (fallback)")]
        [SerializeField] float defaultFadeSeconds = 0.6f;

        Image _image;
        RectTransform _rect;

        void Awake()
        {
            _image = GetComponent<Image>();
            _rect = GetComponent<RectTransform>();
            _image.raycastTarget = false;
            SetAlpha(0f);
        }

        public void Show(Sprite sprite, float seconds)
        {
            if (!_image || sprite == null) return;
            StopAllCoroutines();
            _image.sprite = sprite;
            _image.enabled = true;

            _rect.anchorMin = _rect.anchorMax = new Vector2(0.5f, 0.5f);
            _rect.pivot = new Vector2(0.5f, 0.5f);
            _rect.anchoredPosition = anchoredOffset;

            ApplySizing(sprite);

            SetAlpha(1f);
            float duration = seconds > 0f ? seconds : Mathf.Max(0.0001f, defaultFadeSeconds);
            StartCoroutine(FadeRoutine(duration));
        }

        public void Show(Sprite sprite) => Show(sprite, defaultFadeSeconds);

        public void HideImmediate()
        {
            StopAllCoroutines();
            SetAlpha(0f);
        }

        void ApplySizing(Sprite sprite)
        {
            float canvasScale = 1f;
            var canvas = _rect ? _rect.GetComponentInParent<Canvas>() : null;
            if (canvas) canvasScale = Mathf.Max(0.0001f, canvas.scaleFactor);

            float screenShortest = Mathf.Min(Screen.width, Screen.height);
            float targetPixels = Mathf.Min(maxPixels, screenShortest - 40f);
            float targetUnits = targetPixels / canvasScale;

            if (!useNativeSize || sprite == null)
            {
                _rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, targetUnits);
                _rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, targetUnits);
                return;
            }

            var rect = sprite.rect;
            float w = Mathf.Max(1f, rect.width);
            float h = Mathf.Max(1f, rect.height);
            float scale = targetUnits / Mathf.Max(w, h);
            _rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, w * scale);
            _rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, h * scale);
        }

        IEnumerator FadeRoutine(float duration)
        {
            float t = 0f;
            while (t < duration)
            {
                t += Time.unscaledDeltaTime;
                SetAlpha(1f - t / duration);
                yield return null;
            }
            SetAlpha(0f);
        }

        void SetAlpha(float a)
        {
            if (!_image) return;
            var c = _image.color; c.a = a; _image.color = c;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\FitSpriteToCamera.cs =====

using UnityEngine;

[ExecuteAlways]                       // run in Edit mode too
[RequireComponent(typeof(SpriteRenderer))]
public class FitSpriteToCamera : MonoBehaviour
{
    public enum FitMode { FitInside, Cover }

    [Header("Fit Settings")]
    public FitMode mode = FitMode.Cover;

    [Tooltip("Optional. If not set, uses Camera.main.")]
    public Camera targetCamera;

    void OnEnable()   => Apply();
    void OnValidate() => Apply();

#if UNITY_EDITOR
    // Keep the preview correct while not playing
    void Update()
    {
        if (!Application.isPlaying) Apply();
    }
#endif

    /// <summary>Call this after you change the sprite/background at runtime.</summary>
    public void ApplyNow() => Apply();

    void Apply()
    {
        var sr = GetComponent<SpriteRenderer>();
        if (!sr || !sr.sprite) return;

        var cam = targetCamera ? targetCamera : Camera.main;
        if (!cam) return;

        // Camera world size at the sprite plane
        float worldH, worldW;
        if (cam.orthographic)
        {
            worldH = cam.orthographicSize * 2f;
            worldW = worldH * cam.aspect;
        }
        else
        {
            // Perspective fallback: compute size at sprite depth
            float dist = Mathf.Abs((transform.position - cam.transform.position).z);
            worldH = 2f * dist * Mathf.Tan(cam.fieldOfView * 0.5f * Mathf.Deg2Rad);
            worldW = worldH * cam.aspect;
        }

        // Sprite size in world units at scale = 1
        Vector2 spriteWorld = sr.sprite.bounds.size;

        float sx = worldW / spriteWorld.x;
        float sy = worldH / spriteWorld.y;
        float s  = (mode == FitMode.Cover) ? Mathf.Max(sx, sy) : Mathf.Min(sx, sy);

        transform.localScale = new Vector3(s, s, 1f);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\FullscreenHubController.cs =====

using System.Collections;
using UnityEngine;
using UnityEngine.EventSystems;
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;   // New Input System
#endif

namespace GalacticFishing.UI
{
    [RequireComponent(typeof(CanvasGroup))]
    [AddComponentMenu("Galactic Fishing/UI/Fullscreen Hub Controller")]
    public sealed class FullscreenHubController : MonoBehaviour
    {
        [Header("Toggle (New Input System)")]
        public bool useRightMouse = true;
        public bool requireHold = false;
        [Range(0f, 1f)] public float holdSeconds = 0.2f;

        [Header("Behavior")]
        public bool pauseTime = true;
        public GameObject[] hideWhenOpen;

        [Header("Animation")]
        [Range(0f, 1f)] public float fadeSeconds = 0.18f;

        [Header("Options")]
        public bool openOnStart = false;
        public bool deactivateOnClose = false;
        public bool logInput = false;

        [Header("Cursor")]
        public bool showCursorWhenOpen   = true;
        public bool showCursorWhenClosed = true;   // <-- keep cursor visible in gameplay
        public bool lockCursorWhenOpen   = false;
        public bool lockCursorWhenClosed = false;

        CanvasGroup _group;
        bool _open, _animating;
        float _holdT;

        void Awake()
        {
            _group = GetComponent<CanvasGroup>();
            SetOpen(openOnStart, true);
        }

        void Update()
        {
            bool togglePressed = false;
            bool toggleHeld    = false;

#if ENABLE_INPUT_SYSTEM
            if (useRightMouse && Mouse.current != null)
            {
                togglePressed = Mouse.current.rightButton.wasPressedThisFrame;
                toggleHeld    = Mouse.current.rightButton.isPressed;
            }
            if (_open && Keyboard.current != null && Keyboard.current.escapeKey.wasPressedThisFrame)
                Toggle();
#else
            // Compiles only if legacy Input is enabled in project
            togglePressed = Input.GetMouseButtonDown(1);
            toggleHeld    = Input.GetMouseButton(1);
            if (_open && Input.GetKeyDown(KeyCode.Escape)) Toggle();
#endif

            if (requireHold)
            {
                if (!_open && toggleHeld)
                {
                    _holdT += Time.unscaledDeltaTime;
                    if (_holdT >= holdSeconds) Toggle();
                }
                if (!toggleHeld) _holdT = 0f;
            }
            else
            {
                if (togglePressed)
                {
                    if (logInput) Debug.Log("[Hub] Toggle via RMB");
                    Toggle();
                }
            }
        }

        public void Toggle()
        {
            if (_animating) return;
            SetOpen(!_open, false);
        }

        void SetOpen(bool open, bool instant)
        {
            _open = open;

            if (hideWhenOpen != null)
            {
                foreach (var go in hideWhenOpen)
                    if (go) go.SetActive(!open);
            }

            StopAllCoroutines();
            if (instant) ApplyImmediate(open);
            else StartCoroutine(Fade(open));
        }

        void ApplyImmediate(bool open)
        {
            if (!_group) _group = GetComponent<CanvasGroup>();

            _group.alpha = open ? 1f : 0f;
            _group.blocksRaycasts = open;
            _group.interactable   = open;

            ApplyCursor(open);
            if (pauseTime) Time.timeScale = open ? 0f : 1f;

            if (!open && deactivateOnClose)
                gameObject.SetActive(false);
        }

        IEnumerator Fade(bool open)
        {
            _animating = true;
            if (!_group) _group = GetComponent<CanvasGroup>();
            if (open && !gameObject.activeSelf)
                gameObject.SetActive(true);

            float start  = _group.alpha;
            float target = open ? 1f : 0f;
            float t = 0f;

            while (t < fadeSeconds)
            {
                t += Time.unscaledDeltaTime;
                float k = Mathf.Clamp01(t / Mathf.Max(0.0001f, fadeSeconds));
                _group.alpha = Mathf.Lerp(start, target, k);
                yield return null;
            }

            _group.alpha = target;
            _group.blocksRaycasts = open;
            _group.interactable   = open;

            ApplyCursor(open);
            if (pauseTime) Time.timeScale = open ? 0f : 1f;

            if (!open && deactivateOnClose)
                gameObject.SetActive(false);

            _animating = false;
        }

        void ApplyCursor(bool open)
        {
            bool show = open ? showCursorWhenOpen   : showCursorWhenClosed;
            bool lockIt = open ? lockCursorWhenOpen : lockCursorWhenClosed;

            Cursor.visible = show;
            Cursor.lockState = lockIt ? CursorLockMode.Locked : CursorLockMode.None;
        }

        // ------- Editor helpers -------
        [ContextMenu("Editor: Force Open (Immediate)")]
        void EditorForceOpen()  => SetOpen(true,  true);

        [ContextMenu("Editor: Force Closed (Immediate)")]
        void EditorForceClosed() => SetOpen(false, true);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\GreenZoneController.cs =====

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

namespace GalacticFishing.UI
{
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    public class GreenZoneController : MonoBehaviour
    {
        [Serializable]
        public struct Segment
        {
            [Range(0f, 1f)] public float start01;   // left edge normalized
            [Range(0f, 1f)] public float length01;  // width normalized
        }

        public enum ThicknessMode { Pixels, PercentOfInnerHeight }

        [Header("Assign")]
        [SerializeField] private ReactionBarTrack track;          // required
        [SerializeField] private RectTransform container;         // optional; default = this
        [SerializeField] private Sprite segmentSprite;
        [SerializeField] private Color segmentColor = new Color(0.3f, 1f, 0.4f, 1f);

        [Header("Thickness")]
        [SerializeField] private ThicknessMode thicknessMode = ThicknessMode.PercentOfInnerHeight;
        [Tooltip("If Pixels: exact screen px. If Percent: 0..1 of inner height.")]
        [SerializeField, Min(0f)] private float thickness = 0.35f;

        [Header("Insets / Nudge (screen px)")]
        [Tooltip("Inward padding on each end, in screen pixels.")]
        [SerializeField] private float insetLeftPx = 0f;
        [SerializeField] private float insetRightPx = 0f;
        [Tooltip("Small vertical offset in screen pixels. Keep tiny (Â±0..5).")]
        [SerializeField] private float centerYNudgePx = 0f;

        [Header("Segments (normalized)")]
        [SerializeField] private List<Segment> segments = new List<Segment> {
            new Segment { start01 = 0.35f, length01 = 0.30f }
        };

        [Header("Live Rebuild")]
        [SerializeField] private bool rebuildEveryFrame = true;

        private RectTransform _self;

        private void OnEnable()
        {
            _self = GetComponent<RectTransform>();
            if (!container) container = _self;
            Rebuild();
        }

        private void Update()
        {
            if (rebuildEveryFrame) Rebuild();
        }

        private void OnRectTransformDimensionsChange()
        {
            if (isActiveAndEnabled && !Application.isPlaying) Rebuild();
        }

        // ---- Public helpers -------------------------------------------------

        public void SetSingleCentered(float width01)
        {
            width01 = Mathf.Clamp01(width01);
            float start = Mathf.Clamp01(0.5f - width01 * 0.5f);
            segments = new List<Segment> { new Segment { start01 = start, length01 = width01 } };
            Rebuild();
        }

        public void SetSegments(params Segment[] segs)
        {
            segments = new List<Segment>(segs);
            Rebuild();
        }

        public IReadOnlyList<Segment> CurrentSegments => segments;

        // ---- Internals ------------------------------------------------------

        private static float CanvasScaleFactor(Component c)
        {
            var canvas = c.GetComponentInParent<Canvas>();
            return canvas ? Mathf.Max(0.0001f, canvas.scaleFactor) : 1f;
        }

        private static float PxToLocalX(RectTransform parent, float px)
        {
            float sf = CanvasScaleFactor(parent);
            float sx = Mathf.Max(0.0001f, Mathf.Abs(parent.lossyScale.x));
            return px / (sf * sx);
        }

        private static float PxToLocalY(RectTransform parent, float px)
        {
            float sf = CanvasScaleFactor(parent);
            float sy = Mathf.Max(0.0001f, Mathf.Abs(parent.lossyScale.y));
            return px / (sf * sy);
        }

        public void Rebuild()
        {
            if (track == null || !track.IsValid || !_self) return;

            RectTransform parent = container ? container : _self;

            // Ensure children for segments
            EnsureChildCount(parent, segments.Count);

            // Track inner edges (WORLD)
            float Lw = track.InnerLeftX;
            float Rw = track.InnerRightX;
            float Ww = Rw - Lw;

            // Convert inner top/bottom to LOCAL for height
            float topLocal    = parent.InverseTransformPoint(new Vector3(0f, track.InnerTopY,    0f)).y;
            float bottomLocal = parent.InverseTransformPoint(new Vector3(0f, track.InnerBottomY, 0f)).y;
            float innerHLocal = Mathf.Max(0f, topLocal - bottomLocal);

            // *** THIS is the important line: use the SAME center as the marker ***
            float centerLocalY =
                parent.InverseTransformPoint(new Vector3(0f, track.CenterY, 0f)).y
                + PxToLocalY(parent, centerYNudgePx);

            for (int i = 0; i < segments.Count; i++)
            {
                var seg = segments[i];
                float s0 = Mathf.Clamp01(seg.start01);
                float s1 = Mathf.Clamp01(seg.start01 + seg.length01);
                if (s1 < s0) s1 = s0;

                // Horizontal edges in WORLD â†’ LOCAL
                float leftLocalX  = parent.InverseTransformPoint(new Vector3(Lw + Ww * s0, track.CenterY, 0f)).x;
                float rightLocalX = parent.InverseTransformPoint(new Vector3(Lw + Ww * s1, track.CenterY, 0f)).x;

                // Apply pixel insets (converted to local)
                leftLocalX  += PxToLocalX(parent, insetLeftPx);
                rightLocalX -= PxToLocalX(parent, insetRightPx);

                float widthLocal = Mathf.Max(0f, rightLocalX - leftLocalX);

                // Height
                float heightLocal;
                if (thicknessMode == ThicknessMode.PercentOfInnerHeight)
                    heightLocal = Mathf.Clamp01(thickness) * innerHLocal;
                else // Pixels
                    heightLocal = thickness > 0f ? Mathf.Max(0f, PxToLocalY(parent, thickness)) : innerHLocal;

                // Apply to child rect
                var child = (RectTransform)parent.GetChild(i);
                child.anchorMin = child.anchorMax = new Vector2(0f, 0f);
                child.pivot = new Vector2(0.5f, 0.5f);
                child.sizeDelta = new Vector2(widthLocal, heightLocal);
                child.anchoredPosition = new Vector2(leftLocalX + widthLocal * 0.5f, centerLocalY);

                // Visual
                var img = child.GetComponent<Image>() ?? child.gameObject.AddComponent<Image>();
                img.sprite = segmentSprite;
                img.type   = (segmentSprite && segmentSprite.border != Vector4.zero) ? Image.Type.Sliced : Image.Type.Simple;
                img.color  = segmentColor;
                img.raycastTarget = false;

                child.gameObject.SetActive(true);
            }

            // Disable extras if needed
            for (int i = segments.Count; i < parent.childCount; i++)
                parent.GetChild(i).gameObject.SetActive(false);
        }

        private static void EnsureChildCount(RectTransform parent, int n)
        {
            for (int i = parent.childCount; i < n; i++)
            {
                var go = new GameObject($"Segment_{i}", typeof(RectTransform), typeof(Image));
                var rt = go.GetComponent<RectTransform>();
                go.transform.SetParent(parent, false);
                rt.anchorMin = rt.anchorMax = new Vector2(0f, 0f);
                rt.pivot = new Vector2(0.5f, 0.5f);
            }
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\GridAutoFit.cs =====

using UnityEngine;
using UnityEngine.UI;
using System.Collections;

[ExecuteAlways]
[RequireComponent(typeof(GridLayoutGroup))]
public class GridAutoFit : MonoBehaviour
{
    [Header("Refs")]
    public RectTransform ContentFrame;          // inner area the grid should fill
    public GridLayoutGroup Grid;                // the GridLayoutGroup to drive

    [Header("Layout")]
    [Min(1)] public int Columns = 13;
    [Min(1)] public int Rows    = 6;
    [Min(0)] public float Spacing = 8f;         // gap between cells (pixels)
    [Min(0)] public float InnerMargin = 1f;     // inset from ContentFrame edges (pixels)
    public bool SnapToWholePixels = true;
    public bool Verbose = false;

    void Reset()
    {
        Grid = GetComponent<GridLayoutGroup>();
        if (!ContentFrame) ContentFrame = transform.parent as RectTransform;

        Grid.startCorner   = GridLayoutGroup.Corner.UpperLeft;
        Grid.startAxis     = GridLayoutGroup.Axis.Horizontal;
        Grid.childAlignment= TextAnchor.UpperLeft;
        Grid.constraint    = GridLayoutGroup.Constraint.FixedColumnCount;
    }

    void OnEnable()                    => Run();
    void OnRectTransformDimensionsChange() => Run();

#if UNITY_EDITOR
    void OnValidate()                  => Run();
    void Update() { if (!Application.isPlaying) Apply(); }
#endif

    void Run()
    {
        if (!isActiveAndEnabled) return;
#if UNITY_EDITOR
        if (!Application.isPlaying) { Apply(); return; }
#endif
        // Apply *after* other Awake/OnEnable scripts so our values win.
        StopAllCoroutines();
        StartCoroutine(ApplyNextFrame());
    }

    IEnumerator ApplyNextFrame()
    {
        yield return null;  // let CanvasScaler & any other layout scripts finish
        Apply();
    }

    [ContextMenu("Apply Now")]
    public void Apply()
    {
        if (!Grid) Grid = GetComponent<GridLayoutGroup>();
        if (!ContentFrame || !Grid) return;

        // Pixel-accurate frame size (respects Canvas Scaler)
        Canvas canvas = GetComponentInParent<Canvas>();
        Rect framePx  = RectTransformUtility.PixelAdjustRect(ContentFrame, canvas);

        // Usable width/height after inner margin
        float left = InnerMargin, right = InnerMargin, top = InnerMargin, bottom = InnerMargin;
        float usableW = Mathf.Max(0, framePx.width  - left - right);
        float usableH = Mathf.Max(0, framePx.height - top  - bottom);

        // Total spacing the grid needs to reserve
        float sx = Mathf.Max(0, Spacing) * (Columns - 1);
        float sy = Mathf.Max(0, Spacing) * (Rows    - 1);

        // Square cells that fit both axes
        float cw = (usableW - sx) / Columns;
        float ch = (usableH - sy) / Rows;
        float cell = Mathf.Max(1, Mathf.Min(cw, ch));
        if (SnapToWholePixels) cell = Mathf.Floor(cell);
        float spacingOut = SnapToWholePixels ? Mathf.Round(Spacing) : Spacing;

        // Drive the Grid
        Grid.constraint      = GridLayoutGroup.Constraint.FixedColumnCount;
        Grid.constraintCount = Mathf.Max(1, Columns);
        Grid.startCorner     = GridLayoutGroup.Corner.UpperLeft;
        Grid.startAxis       = GridLayoutGroup.Axis.Horizontal;
        Grid.childAlignment  = TextAnchor.UpperLeft;

        Grid.padding.left    = Mathf.RoundToInt(left);
        Grid.padding.right   = Mathf.RoundToInt(right);
        Grid.padding.top     = Mathf.RoundToInt(top);
        Grid.padding.bottom  = Mathf.RoundToInt(bottom);
        Grid.spacing         = new Vector2(spacingOut, spacingOut);
        Grid.cellSize        = new Vector2(cell, cell);

        if (Verbose)
            Debug.Log($"[GridAutoFit] frame={framePx.size}  cell={cell}  spacing={spacingOut}  cols={Columns} rows={Rows}");
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HookCardOwnedBinder.cs =====

// Assets/Scripts/UI/HookCardOwnedBinder.cs
// v3: Namespace-proof (no direct compile dependency on FishRegistry).
// - The "Registry" field now accepts ANY ScriptableObject/asset; we reflect a public or private field named "fishes".
// - Each entry is assumed to be a UnityEngine.Object with .name and (optionally) a string field/property "displayName".
// - You still get live updates via InventoryService.OnChanged and SetSpeciesId(int) for direct injection.
//
// Wiring: assign Species Name, Sub Text, and drag your FishRegistry asset into "Registry".

using UnityEngine;
using TMPro;
using System.Collections;
using System.Reflection;

[DefaultExecutionOrder(200)]
public class HookCardOwnedBinder : MonoBehaviour
{
    [Header("HookCard UI (assign in prefab)")]
    [SerializeField] private TMP_Text speciesName;
    [SerializeField] private TMP_Text subText;

    [Header("Data (same source as grid)")]
    [Tooltip("Drag your FishRegistry asset here. The script will read its 'fishes' list via reflection.")]
    [SerializeField] private UnityEngine.Object registry;

    [Header("Options")]
    [SerializeField] private bool logs = false;

    string _lastTitle = null;
    int _currentId = -1;

    // Cache for reflection
    FieldInfo _fishesField;
    PropertyInfo _fishesProp;

    // --- Public API: allow external systems to set the id directly (best case).
    public void SetSpeciesId(int speciesId)
    {
        _currentId = speciesId;
        if (logs) Debug.Log($"[HookCardOwnedBinder] External SetSpeciesId â†’ {speciesId}");
        UpdateText();
    }

    void Awake()
    {
        if (registry != null)
        {
            var t = registry.GetType();
            _fishesField = t.GetField("fishes", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            _fishesProp  = t.GetProperty("fishes", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (logs) Debug.Log($"[HookCardOwnedBinder] Registry bound via reflection. field? {(_fishesField!=null)} prop? {(_fishesProp!=null)}");
        }
    }

    void OnEnable()
    {
        InventoryService.OnChanged += OnInventoryChanged;
        ForceRefresh();
    }

    void OnDisable()
    {
        InventoryService.OnChanged -= OnInventoryChanged;
        _currentId = -1;
        _lastTitle = null;
    }

    void Update()
    {
        if (!speciesName) return;

        var title = speciesName.text?.Trim();
        if (title != _lastTitle)
        {
            _lastTitle = title;
            _currentId = ResolveIdFromTitle(title);
            if (logs) Debug.Log($"[HookCardOwnedBinder] Title change â†’ '{title}'  id={_currentId}");
            UpdateText();
        }
    }

    void OnInventoryChanged()
    {
        if (isActiveAndEnabled)
            UpdateText();
    }

    void ForceRefresh()
    {
        if (speciesName)
        {
            _lastTitle = speciesName.text?.Trim();
            _currentId = ResolveIdFromTitle(_lastTitle);
        }
        UpdateText();
    }

    int ResolveIdFromTitle(string title)
    {
        if (registry == null || string.IsNullOrWhiteSpace(title))
            return _currentId >= 0 ? _currentId : -1;

        string want = Normalize(title);
        string wantNoDigits = StripTrailingDigits(want);

        IList fishes = GetFishesList();
        if (fishes == null) return -1;

        int best = -1;

        for (int i = 0; i < fishes.Count; i++)
        {
            var defObj = fishes[i] as UnityEngine.Object;
            if (!defObj) continue;

            string assetName = Normalize(defObj.name);
            string displayName = Normalize(GetDisplayName(defObj));

            // Exact match first
            if (want == displayName || want == assetName) return i;

            // Variant-safe trailing digits
            if (wantNoDigits == displayName || wantNoDigits == assetName) best = i;
            else if (want.StartsWith(displayName) || want.StartsWith(assetName) ||
                     displayName.StartsWith(wantNoDigits) || assetName.StartsWith(wantNoDigits))
                best = i;
        }

        return best;
    }

    IList GetFishesList()
    {
        if (registry == null) return null;
        if (_fishesField != null) return _fishesField.GetValue(registry) as IList;
        if (_fishesProp  != null) return _fishesProp.GetValue(registry) as IList;
        return null;
    }

    string GetDisplayName(UnityEngine.Object fishDef)
    {
        // Try field or property named "displayName"
        var t = fishDef.GetType();
        var f = t.GetField("displayName", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (f != null && f.FieldType == typeof(string))
            return (string)f.GetValue(fishDef);

        var p = t.GetProperty("displayName", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (p != null && p.PropertyType == typeof(string))
            return (string)p.GetValue(fishDef, null);

        return fishDef.name; // fallback
    }

    void UpdateText()
    {
        int n = 0;

        if (_currentId >= 0 && InventoryService.IsInitialized)
        {
            foreach (var t in InventoryService.All())
            {
                if (t.id == _currentId) { n = Mathf.Max(0, t.count); break; }
            }
        }

        if (subText) subText.text = $"OWNED: {n}";
        if (logs) Debug.Log($"[HookCardOwnedBinder] Shown â†’ OWNED: {n} (id={_currentId})");
    }

    static string Normalize(string s)
    {
        if (string.IsNullOrEmpty(s)) return "";
        System.Text.StringBuilder sb = new System.Text.StringBuilder(s.Length);
        foreach (char c in s)
        {
            if (char.IsLetterOrDigit(c)) sb.Append(char.ToLowerInvariant(c));
        }
        return sb.ToString();
    }

    static string StripTrailingDigits(string s)
    {
        if (string.IsNullOrEmpty(s)) return "";
        int end = s.Length;
        while (end > 0 && char.IsDigit(s[end - 1])) end--;
        return s.Substring(0, end);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HoverTargetHUD.cs =====

// HoverTargetHUD.cs â€” topmost fish wins, 2D trigger-friendly
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.UI;
using System;
using System.Reflection;

public class HoverTargetHUD : MonoBehaviour
{
    [Header("Assign")]
    [SerializeField] private Camera worldCamera;          // leave empty to use Camera.main
    [SerializeField] private LayerMask fishMask = ~0;     // set to your Fish layer

    [Header("UI (drag Text OR TMP_Text)")]
    [SerializeField] private MonoBehaviour textComponent; // UnityEngine.UI.Text OR TMPro.TMP_Text

    [Header("Copy")]
    [SerializeField] private string prefix = "Target: ";
    [SerializeField] private string noneText = "Target: â€”";
    [Header("Quality")]
    [SerializeField] private bool showQuality = true;
    [SerializeField] private bool useMetaFallback = false;   // show FishMeta-level quality if runtime has none
    [SerializeField] private string qualityPrefix = " - Q: ";
    [SerializeField] private string qualityNotRolledText = " - Q: (not rolled)";
    [SerializeField] private string qualityUnavailableText = " - Q: (n/a)";

    private Text _u; private TMPro.TMP_Text _tmp;

    void Awake()
    {
        if (!worldCamera) worldCamera = Camera.main;
        _u = textComponent as Text;
        _tmp = textComponent as TMPro.TMP_Text;
        if (!_u && !_tmp) { TryGetComponent(out _u); TryGetComponent(out _tmp); }
        SetLabel(null);
    }

    void Update()
    {
        if (!worldCamera) worldCamera = Camera.main;

        Vector2 screen = (Mouse.current != null)
            ? Mouse.current.position.ReadValue()
            : (Vector2)Input.mousePosition;

        Vector2 world = worldCamera.ScreenToWorldPoint(screen);

        // Grab all colliders under the cursor (triggers included)
        var hits = Physics2D.OverlapPointAll(world, fishMask);

        FishIdentity best = null;
        int bestKey = int.MinValue;

        foreach (var h in hits)
        {
            var id = h.GetComponentInParent<FishIdentity>();
            if (!id) continue;

            // Find the renderer we actually see
            var sr = id.GetComponentInChildren<SpriteRenderer>();
            if (!sr) { best = id; bestKey = int.MaxValue; break; }

            // Build a render priority key: sorting layer value then order in layer
            int layerVal = SortingLayer.GetLayerValueFromID(sr.sortingLayerID);
            int key = (layerVal << 16) + sr.sortingOrder;

            // Optional: tie-breaker by Z (higher Z in front if you use perspective)
            key += Mathf.RoundToInt(-sr.transform.position.z * 10f);

            if (key > bestKey) { bestKey = key; best = id; }
        }

        SetLabel(best);
    }

    void SetLabel(FishIdentity fish)
    {
        string t = fish ? (prefix + fish.DisplayName) : noneText;
        if (fish && showQuality)
        {
            if (TryGetRuntimeQuality(fish, out var val, out var hasValue))
            {
                t += hasValue ? (qualityPrefix + val) : qualityNotRolledText;
            }
            else if (useMetaFallback && TryGetMetaQuality(fish, out var metaVal))
            {
                t += qualityPrefix + metaVal;
            }
            else
            {
                t += qualityUnavailableText;
            }
        }
        if (_u) _u.text = t;
        if (_tmp) _tmp.text = t;
    }

    bool TryGetRuntimeQuality(FishIdentity fish, out int value, out bool hasValue)
    {
        value = 0; hasValue = false;
        if (!fish) return false;
        var qType = Type.GetType("GalacticFishing.FishQualityRuntime") ?? Type.GetType("FishQualityRuntime");
        if (qType == null) return false;
        var comp = fish.GetComponentInChildren(qType);
        if (!comp) return false;
        var hasProp = qType.GetProperty("HasValue", BindingFlags.Instance | BindingFlags.Public);
        var valProp = qType.GetProperty("Value", BindingFlags.Instance | BindingFlags.Public);
        if (hasProp == null || valProp == null) return false;
        hasValue = (bool)hasProp.GetValue(comp);
        if (hasValue)
        {
            var obj = valProp.GetValue(comp);
            if (obj != null) value = Convert.ToInt32(obj);
        }
        return true;
    }

    bool TryGetMetaQuality(FishIdentity fish, out int value)
    {
        value = 0;
        if (!fish) return false;
        object metaObj = null;
        var t = fish.GetType();
        var fi = t.GetField("meta", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
              ?? t.GetField("Meta", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (fi != null) metaObj = fi.GetValue(fish);
        if (metaObj == null)
        {
            var pi = t.GetProperty("meta", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                   ?? t.GetProperty("Meta", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (pi != null && pi.CanRead) metaObj = pi.GetValue(fish);
        }
        if (metaObj is not ScriptableObject so) return false;
        var mt = so.GetType();
        var qf = mt.GetField("quality", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
              ?? mt.GetField("Quality", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (qf != null)
        {
            value = Mathf.RoundToInt(Convert.ToSingle(qf.GetValue(so)));
            return true;
        }
        var qp = mt.GetProperty("quality", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
               ?? mt.GetProperty("Quality", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (qp != null && qp.CanRead)
        {
            value = Mathf.RoundToInt(Convert.ToSingle(qp.GetValue(so)));
            return true;
        }
        return false;
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HubArtLayout.cs =====

using UnityEngine;

namespace GalacticFishing.UI
{
    [ExecuteAlways]
    [AddComponentMenu("Galactic Fishing/UI/Hub Art Layout")]
    public sealed class HubArtLayout : MonoBehaviour
    {
        public RectTransform leftColumn;
        public RectTransform gridArea;

        public Rect leftRect = new Rect(0.05f, 0.18f, 0.28f, 0.64f);
        public Rect gridRect = new Rect(0.36f, 0.18f, 0.60f, 0.70f);

        void OnEnable()   => Apply();
        void OnValidate() => Apply();

        void Update()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) Apply();
#endif
        }

        void Apply()
        {
            if (leftColumn) Set(leftColumn, leftRect);
            if (gridArea) Set(gridArea, gridRect);
        }

        static void Set(RectTransform t, Rect r)
        {
            var min = new Vector2(r.xMin, r.yMin);
            var max = new Vector2(r.xMax, r.yMax);
            t.anchorMin = min;
            t.anchorMax = max;
            t.offsetMin = t.offsetMax = Vector2.zero;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HubGridPopulator.cs =====

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace GalacticFishing.UI
{
    [System.Serializable]
    public sealed class HubTile
    {
        public string label;
        public Sprite icon;
        public bool interactable = true;
        public UnityEngine.Events.UnityEvent onClick = new();
        public string hoverText;
    }

    [RequireComponent(typeof(RectTransform))]
    [AddComponentMenu("Galactic Fishing/UI/Hub Grid Populator")]
    public sealed class HubGridPopulator : MonoBehaviour
    {
        public RectTransform gridRoot;
        public List<HubTile> tiles = new();
        public int columns = 3;
        public Vector2 spacing = new(24, 24);
        public Vector2 padding = new(24, 24);
        public Sprite tileSprite;
        public Color tileColor = new(0.08f, 0.14f, 0.2f, 0.92f);
        public Color tileDisabled = new(0.08f, 0.14f, 0.2f, 0.45f);
        public Color labelColor = Color.white;
        public Color labelDisabled = new(0.85f, 0.85f, 0.85f, 0.7f);
        public TMP_FontAsset font;
        public bool showLabels = false;

        HubHoverHint _hint;

        void Awake()
        {
            if (!gridRoot) gridRoot = (RectTransform)transform;
            _hint = GetComponentInParent<HubHoverHint>();
            Build();
        }

        public void Build()
        {
            for (int i = gridRoot.childCount - 1; i >= 0; i--)
                DestroyImmediate(gridRoot.GetChild(i).gameObject);

            var gl = gridRoot.GetComponent<GridLayoutGroup>() ?? gridRoot.gameObject.AddComponent<GridLayoutGroup>();
            gl.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
            gl.constraintCount = Mathf.Max(1, columns);
            gl.spacing = spacing;
            gl.padding = new RectOffset((int)padding.x, (int)padding.x, (int)padding.y, (int)padding.y);

            var size = gridRoot.rect.size;
            float availW = Mathf.Max(0f, size.x - padding.x * 2f - spacing.x * (columns - 1));
            float cell = columns > 0 ? Mathf.Floor(availW / columns) : 100f;
            gl.cellSize = new Vector2(cell, cell);

            foreach (var t in tiles) CreateTile(t, cell);
        }

        void CreateTile(HubTile tile, float cell)
        {
            var go = new GameObject($"Tile_{(string.IsNullOrEmpty(tile.label) ? "Item" : tile.label)}",
                typeof(RectTransform), typeof(Image), typeof(Button));
            var rt = (RectTransform)go.transform;
            rt.SetParent(gridRoot, false);
            rt.sizeDelta = new Vector2(cell, cell);

            var img = go.GetComponent<Image>();
            img.sprite = tileSprite;
            img.type = tileSprite ? Image.Type.Sliced : Image.Type.Simple;
            img.color = tile.interactable ? tileColor : tileDisabled;

            var btn = go.GetComponent<Button>();
            btn.interactable = tile.interactable;
            btn.onClick.AddListener(() => tile.onClick?.Invoke());

            var relay = go.AddComponent<TileHoverRelay>();
            relay.hint = _hint;
            relay.text = string.IsNullOrWhiteSpace(tile.hoverText) ? tile.label : tile.hoverText;

            if (tile.icon)
            {
                var iconGO = new GameObject("Icon", typeof(RectTransform), typeof(Image));
                var iconRT = (RectTransform)iconGO.transform;
                iconRT.SetParent(rt, false);
                iconRT.anchorMin = iconRT.anchorMax = new Vector2(0.5f, 0.65f);
                iconRT.sizeDelta = new Vector2(cell * 0.45f, cell * 0.45f);
                var iconImg = iconGO.GetComponent<Image>();
                iconImg.sprite = tile.icon;
                iconImg.raycastTarget = false;
                if (!tile.interactable) iconImg.color = new Color(1, 1, 1, 0.6f);
            }

            if (showLabels)
            {
                var labelGO = new GameObject("Label", typeof(RectTransform), typeof(TextMeshProUGUI));
                var labelRT = (RectTransform)labelGO.transform;
                labelRT.SetParent(rt, false);
                labelRT.anchorMin = new Vector2(0.12f, 0.08f);
                labelRT.anchorMax = new Vector2(0.88f, 0.35f);
                labelRT.offsetMin = labelRT.offsetMax = Vector2.zero;

                var tmp = labelGO.GetComponent<TextMeshProUGUI>();
                tmp.text = string.IsNullOrWhiteSpace(tile.label) ? " " : tile.label;
                tmp.alignment = TextAlignmentOptions.Center;
                tmp.enableAutoSizing = true;
                tmp.fontSizeMin = 12;
                tmp.fontSizeMax = 42;
                tmp.color = tile.interactable ? labelColor : labelDisabled;
                if (font) tmp.font = font;
                tmp.raycastTarget = false;
            }
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HubHoverHint.cs =====

using TMPro;
using UnityEngine;

namespace GalacticFishing.UI
{
    [AddComponentMenu("Galactic Fishing/UI/Hub Hover Hint")]
    public sealed class HubHoverHint : MonoBehaviour
    {
        [SerializeField] TMP_Text label;
        [SerializeField] string idleText = "";

        public void Set(string text) { if (label) label.text = text; }
        public void Clear()          { if (label) label.text = idleText; }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HubPanelController.cs =====

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;
using TMPro;

namespace GalacticFishing.UI
{
    public sealed class HubPanelController : MonoBehaviour
    {
        [Header("Scene References")]
        [SerializeField] private Transform leftColumn;   // Panel_Hub/LeftColumn
        [SerializeField] private Transform rightGrid;    // Panel_Hub/RightGrid

        [Header("Worlds Tab")]
        [SerializeField] private GalacticFishing.WorldManager worldManager;
        [SerializeField] private List<GalacticFishing.WorldDefinition> worlds = new();

        [Header("Custom Tabs")]
        [SerializeField] private List<CustomPage> customPages = new(); // e.g., UPGRADES

        [Header("Behaviour")]
        [SerializeField] private bool closePanelAfterWorldPick = false;

        [Header("GRID Label Style (Right side)")]
        [SerializeField] private bool gridUseAutoSize = true;
        [SerializeField] private float gridAutoMin = 16f;
        [SerializeField] private float gridAutoMax = 40f;
        [SerializeField] private TextOverflowModes gridOverflow = TextOverflowModes.Ellipsis;
        [SerializeField] private bool gridWordWrap = false;
        [SerializeField] private bool smartTwoLineIfLong = false;
        [SerializeField] private int twoLineThreshold = 12;

        [Header("LEFT TAB Label Style (override)")]
        [SerializeField] private bool leftUseAutoSize = true;
        [SerializeField] private float leftAutoMin = 28f;
        [SerializeField] private float leftAutoMax = 96f;
        [SerializeField] private TextOverflowModes leftOverflow = TextOverflowModes.Ellipsis;
        [SerializeField] private bool leftWordWrap = false;

        [Header("Pagination (auto builds PREV/NEXT)")]
        [SerializeField] private bool autoBuildPagerUI = true;
        [SerializeField] private bool showPagerWhenSinglePage = false;
        [SerializeField] private Vector2 pagerOffset = new Vector2(0f, -16f);
        [SerializeField] private bool pagerStackVertical = false; // show stack (1, â€”, 2) instead of 1/2
        [SerializeField] private string pagerDivider = "â€”";
        [SerializeField] private string pagerSlash = "/";

        // runtime pager refs
        [SerializeField] private Button pagerPrev;
        [SerializeField] private TMP_Text pagerText;
        [SerializeField] private Button pagerNext;
        private LayoutElement pagerLabelLE; // <â€” was missing

        [Header("Pagination Style")]
        [SerializeField] private string prevLabel = "PREV <";
        [SerializeField] private string nextLabel = "> NEXT";
        [SerializeField] private float pagerFontSize = 32f;
        [SerializeField] private Color pagerTextColor = Color.white;
        [SerializeField] private Vector2 pagerButtonSize = new Vector2(140f, 44f);
        [SerializeField] private float pagerSpacing = 24f;

        [Tooltip("Optional sprite for PREV/NEXT button background (leave null for clean).")]
        [SerializeField] private Sprite pagerButtonSprite = null;

        [Tooltip("Background color; if fully transparent, we'll auto-set to very small alpha so the full rect is clickable.")]
        [SerializeField] private Color pagerButtonColor = new Color(1, 1, 1, 0f);

        // ----- internal -----
        private List<Cell> _left = new();
        private List<Cell> _grid = new();

        private int _currentTabType = 0;  // 0=Museum, 1=Worlds, 2+=Custom
        private int _currentPage = 0;
        private int _pageSize = 15;
        private int _pageCount = 1;

        [System.Serializable] public class CustomPage { public string tabLabel = "UPGRADES"; public List<CustomItem> items = new(); }
        [System.Serializable] public class CustomItem { public string label = "Item"; public Sprite icon; public UnityEvent onClick; }

        private struct Cell
        {
            public GameObject go;
            public Button     button;
            public TMP_Text   label;
            public Image      icon;
        }

        void Awake()
        {
            if (!leftColumn || !rightGrid) { Debug.LogWarning("[HubPanelController] Assign LeftColumn & RightGrid."); return; }

            _left = CollectCells(leftColumn);
            _grid = CollectCells(rightGrid);
            _pageSize = _grid.Count;

            ApplyLeftLabelStyle();
            ApplyGridLabelStyle();

            if (autoBuildPagerUI) EnsurePagerUI();
            WirePagerButtons();

            SetupLeftTabs();
            ShowMuseumPage();
        }

        // ---------- collect tiles ----------
        private List<Cell> CollectCells(Transform parent)
        {
            var list = new List<Cell>(parent.childCount);
            for (int i = 0; i < parent.childCount; i++)
            {
                var t = parent.GetChild(i);
                var go = t.gameObject;

                var img = go.GetComponent<Image>(); if (!img) img = go.AddComponent<Image>();
                var btn = go.GetComponent<Button>(); if (!btn) btn = go.AddComponent<Button>();
                if (!btn.targetGraphic) btn.targetGraphic = img;
                btn.navigation = new Navigation { mode = Navigation.Mode.None };

                var label = go.GetComponentInChildren<TMP_Text>(true);
                Image icon = null; var iconTr = go.transform.Find("Icon"); if (iconTr) icon = iconTr.GetComponent<Image>();

                list.Add(new Cell { go = go, button = btn, label = label, icon = icon });
            }
            return list;
        }

        private void StyleLabel(TMP_Text L, bool useAuto, float min, float max, TextOverflowModes overflow, bool wrap)
        {
            if (!L) return;
            L.enableAutoSizing = useAuto;
            if (useAuto) { L.fontSizeMin = min; L.fontSizeMax = max; }
            L.overflowMode = overflow;
            L.enableWordWrapping = wrap;
            L.ForceMeshUpdate();
        }

        private void ApplyLeftLabelStyle() { foreach (var c in _left) StyleLabel(c.label, leftUseAutoSize, leftAutoMin, leftAutoMax, leftOverflow, leftWordWrap); }
        private void ApplyGridLabelStyle() { foreach (var c in _grid) StyleLabel(c.label, gridUseAutoSize, gridAutoMin, gridAutoMax, gridOverflow, gridWordWrap); }

        private string MakeFit(string s)
        {
            if (!smartTwoLineIfLong || string.IsNullOrEmpty(s) || s.Length < twoLineThreshold) return s;
            int space = s.IndexOf(' ');
            return (space > 0 && space < s.Length - 1) ? s[..space] + "\n" + s[(space + 1)..] : s;
        }

        // ---------- pager UI ----------
        private void EnsurePagerUI()
        {
            if (pagerPrev && pagerText && pagerNext) return;

            var rg = rightGrid as RectTransform;
            if (!rg) return;

            // Root container
            var rootGO = new GameObject("Pager", typeof(RectTransform));
            var rootRT = (RectTransform)rootGO.transform;
            rootRT.SetParent(rg, false);
            rootRT.anchorMin = new Vector2(0.5f, 0f);
            rootRT.anchorMax = new Vector2(0.5f, 0f);
            rootRT.pivot     = new Vector2(0.5f, 1f);
            rootRT.anchoredPosition = pagerOffset;
            rootRT.SetAsLastSibling(); // on top for raycasts

            // Layout
            var h = rootGO.AddComponent<HorizontalLayoutGroup>();
            h.childAlignment = TextAnchor.MiddleCenter;
            h.spacing = pagerSpacing;
            h.padding = new RectOffset(0,0,0,0);

            // PREV button
            pagerPrev = CreateTextButton("Prev", prevLabel, rootRT);

            // label
            pagerText = CreatePagerLabel("Page", "1/1", rootRT);

            // NEXT button
            pagerNext = CreateTextButton("Next", nextLabel, rootRT);
        }

        private Button CreateTextButton(string name, string label, RectTransform parent)
        {
            // Root button includes LayoutElement so HorizontalLayoutGroup respects its slot.
            var go = new GameObject(name, typeof(RectTransform), typeof(Image), typeof(Button), typeof(LayoutElement));
            var rt = (RectTransform)go.transform;
            rt.SetParent(parent, false);
            rt.sizeDelta = pagerButtonSize;

            var layout = go.GetComponent<LayoutElement>();
            layout.minWidth = pagerButtonSize.x; layout.preferredWidth = pagerButtonSize.x;
            layout.minHeight = pagerButtonSize.y; layout.preferredHeight = pagerButtonSize.y;

            var img = go.GetComponent<Image>();
            img.sprite = pagerButtonSprite;
            img.color = pagerButtonColor;
            img.raycastTarget = true;
            img.alphaHitTestMinimumThreshold = 0f;

            var btn = go.GetComponent<Button>();
            btn.targetGraphic = img;
            btn.transition = Selectable.Transition.None;

            var txtGo = new GameObject("Text", typeof(RectTransform));
            var txtRt = (RectTransform)txtGo.transform;
            txtRt.SetParent(rt, false);
            txtRt.anchorMin = Vector2.zero;
            txtRt.anchorMax = Vector2.one;
            txtRt.offsetMin = Vector2.zero;
            txtRt.offsetMax = Vector2.zero;
            txtRt.pivot = new Vector2(0.5f, 0.5f);

            var tmp = txtGo.AddComponent<TextMeshProUGUI>();
            tmp.text = label;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.enableAutoSizing = false;
            tmp.fontSize = pagerFontSize;
            tmp.color = pagerTextColor;
            tmp.enableWordWrapping = false;
            tmp.overflowMode = TextOverflowModes.Overflow;
            tmp.raycastTarget = false;

            return btn;
        }

        private TMP_Text CreatePagerLabel(string name, string label, RectTransform parent)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(LayoutElement));
            var rt = (RectTransform)go.transform;
            rt.SetParent(parent, false);
            rt.sizeDelta = new Vector2(120f, pagerButtonSize.y);

            pagerLabelLE = go.GetComponent<LayoutElement>();
            pagerLabelLE.minWidth = 120f; pagerLabelLE.preferredWidth = 120f;
            pagerLabelLE.minHeight = pagerButtonSize.y; pagerLabelLE.preferredHeight = pagerButtonSize.y;

            var tmp = go.AddComponent<TextMeshProUGUI>();
            tmp.enableWordWrapping = false; tmp.overflowMode = TextOverflowModes.Overflow;
            tmp.text = label;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.enableAutoSizing = false;
            tmp.fontSize = Mathf.Max(18f, pagerFontSize * 0.8f);
            tmp.color = pagerTextColor;
            tmp.raycastTarget = false;
            return tmp;
        }

        private void WirePagerButtons()
        {
            if (pagerPrev) { pagerPrev.onClick.RemoveAllListeners(); pagerPrev.onClick.AddListener(PrevPage); }
            if (pagerNext) { pagerNext.onClick.RemoveAllListeners(); pagerNext.onClick.AddListener(NextPage); }
        }

        private void PrevPage()
        {
            if (_pageCount <= 1) return;
            _currentPage = Mathf.Clamp(_currentPage - 1, 0, _pageCount - 1);
            RedrawCurrentTab();
        }

        private void NextPage()
        {
            if (_pageCount <= 1) return;
            _currentPage = Mathf.Clamp(_currentPage + 1, 0, _pageCount - 1);
            RedrawCurrentTab();
        }

        private void UpdatePager(int page, int pages)
        {
            _pageCount = Mathf.Max(1, pages);
            _currentPage = Mathf.Clamp(page, 0, _pageCount - 1);

            ApplyPagerMode(_currentPage + 1, _pageCount);
            if (pagerPrev) pagerPrev.interactable = (_currentPage > 0);
            if (pagerNext) pagerNext.interactable = (_currentPage < _pageCount - 1);

            var show = showPagerWhenSinglePage ? true : (_pageCount > 1);
            if (pagerPrev) pagerPrev.gameObject.SetActive(show);
            if (pagerText) pagerText.gameObject.SetActive(show);
            if (pagerNext) pagerNext.gameObject.SetActive(show);
        }

        // ---------- tabs ----------
        private void SetupLeftTabs()
        {
            if (_left.Count > 0 && _left[0].label) _left[0].label.text = "MUSEUM";
            if (_left.Count > 1 && _left[1].label) _left[1].label.text = "WORLDS";

            if (_left.Count > 0) _left[0].button.onClick.AddListener(() => { _currentTabType = 0; _currentPage = 0; ShowMuseumPage(); });
            if (_left.Count > 1) _left[1].button.onClick.AddListener(() => { _currentTabType = 1; _currentPage = 0; ShowWorldsPage(); });

            int start = 2;
            for (int i = 0; i < customPages.Count; i++)
            {
                int li = start + i; if (li >= _left.Count) break;
                var page = customPages[i];
                if (_left[li].label) _left[li].label.text = page.tabLabel;
                int cap = i;
                _left[li].button.onClick.AddListener(() =>
                {
                    _currentTabType = 2 + cap;
                    _currentPage = 0;
                    ShowCustomPage(cap);
                });
            }
        }

        private void RedrawCurrentTab()
        {
            if (_currentTabType == 0) ShowMuseumPage();
            else if (_currentTabType == 1) ShowWorldsPage();
            else ShowCustomPage(_currentTabType - 2);
        }

        // ---------- pages ----------
        private void ShowMuseumPage()
        {
            for (int i = 0; i < _grid.Count; i++)
            {
                var c = _grid[i];
                c.go.SetActive(true);
                if (c.icon) c.icon.enabled = false;

                string text = (i < 10) ? "SELL" : "Future Content";
                if (smartTwoLineIfLong) text = MakeFit(text);
                if (c.label) c.label.text = text;

                c.button.onClick.RemoveAllListeners();
            }
            UpdatePager(0, 1);
        }

        private void ShowWorldsPage()
        {
            int total = worlds.Count;
            int pages = Mathf.Max(1, Mathf.CeilToInt(total / (float)_pageSize));
            _currentPage = Mathf.Clamp(_currentPage, 0, pages - 1);

            int start = _currentPage * _pageSize;
            int end   = Mathf.Min(start + _pageSize, total);

            int gridIdx = 0;
            for (int i = start; i < end && gridIdx < _grid.Count; i++, gridIdx++)
            {
                var c = _grid[gridIdx];
                var w = worlds[i];
                c.go.SetActive(true);
                if (c.icon) { c.icon.sprite = null; c.icon.enabled = false; }

                string name = (w && !string.IsNullOrWhiteSpace(w.displayName)) ? w.displayName : $"World {i + 1}";
                if (smartTwoLineIfLong) name = MakeFit(name);
                if (c.label) c.label.text = name;

                c.button.onClick.RemoveAllListeners();
                int captureIndex = i;
                c.button.onClick.AddListener(() =>
                {
                    if (worldManager && worlds[captureIndex] != null)
                    {
                        worldManager.world = worlds[captureIndex];
                        worldManager.lakeIndex = 0;
                        worldManager.ApplyWorldContext();
                    }
                    if (closePanelAfterWorldPick)
                    {
                        var cg = GetComponent<CanvasGroup>(); if (cg) cg.alpha = 0f;
                        gameObject.SetActive(false);
                    }
                });
            }

            for (; gridIdx < _grid.Count; gridIdx++) _grid[gridIdx].go.SetActive(false);

            UpdatePager(_currentPage, pages);
        }

        private void ShowCustomPage(int pageIndex)
        {
            if (pageIndex < 0 || pageIndex >= customPages.Count) { UpdatePager(0, 1); return; }
            var page = customPages[pageIndex];

            int total = page.items.Count;
            int pages = Mathf.Max(1, Mathf.CeilToInt(total / (float)_pageSize));
            _currentPage = Mathf.Clamp(_currentPage, 0, pages - 1);

            int start = _currentPage * _pageSize;
            int end   = Mathf.Min(start + _pageSize, total);

            int gridIdx = 0;
            for (int i = start; i < end && gridIdx < _grid.Count; i++, gridIdx++)
            {
                var c = _grid[gridIdx];
                var item = page.items[i];
                c.go.SetActive(true);

                string text = smartTwoLineIfLong ? MakeFit(item.label) : item.label;
                if (c.label) c.label.text = text;

                if (c.icon) { c.icon.sprite = item.icon; c.icon.enabled = (item.icon != null); }

                c.button.onClick.RemoveAllListeners();
                if (item.onClick != null) c.button.onClick.AddListener(() => item.onClick.Invoke());
            }

            for (; gridIdx < _grid.Count; gridIdx++) _grid[gridIdx].go.SetActive(false);

            UpdatePager(_currentPage, pages);
        }

        private void ApplyPagerMode(int current, int total)
        {
            if (!pagerText) return;

            if (pagerStackVertical)
            {
                // Use explicit newline characters so we don't create multi-line literals in code.
                pagerText.text = current.ToString() + "\n" + pagerDivider + "\n" + total.ToString();
                pagerText.alignment = TextAlignmentOptions.Center;
                if (pagerLabelLE != null)
                {
                    pagerLabelLE.minWidth = 40f;
                    pagerLabelLE.preferredWidth = 40f;
                    pagerLabelLE.minHeight = Mathf.Max(pagerButtonSize.y, 60f);
                    pagerLabelLE.preferredHeight = Mathf.Max(pagerButtonSize.y, 60f);
                }
            }
            else
            {
                pagerText.text = current.ToString() + pagerSlash + total.ToString();
                pagerText.alignment = TextAlignmentOptions.Center;
                if (pagerLabelLE != null)
                {
                    pagerLabelLE.minWidth = 120f;
                    pagerLabelLE.preferredWidth = 120f;
                    pagerLabelLE.minHeight = pagerButtonSize.y;
                    pagerLabelLE.preferredHeight = pagerButtonSize.y;
                }
            }
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryDetailView.cs =====

// Assets/Scripts/UI/InventoryDetailView.cs
// Detail panel that shows Top 5 (formats #1 with cross-stats) + Breeding Tank.

using System.Text;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class InventoryDetailView : MonoBehaviour
{
    [Header("Wiring")]
    [SerializeField] private CanvasGroup group;
    [SerializeField] private TMP_Text title;
    [SerializeField] private TMP_Text body;
    [SerializeField] private Button backButton;

    [Header("Layout")]
    [SerializeField, Min(1)] private int entriesPerList = 5;

    public static InventoryDetailView EnsureUnder(RectTransform contentFrame)
    {
        var existing = contentFrame.transform.Find("DetailArea") as RectTransform;
        if (!existing)
        {
            var go = new GameObject("DetailArea", typeof(RectTransform));
            existing = (RectTransform)go.transform;
            existing.SetParent(contentFrame, false);
            existing.anchorMin = Vector2.zero;
            existing.anchorMax = Vector2.one;
            existing.offsetMin = Vector2.zero;
            existing.offsetMax = Vector2.zero;

            var cg = go.AddComponent<CanvasGroup>();
            cg.alpha = 0f; cg.interactable = false; cg.blocksRaycasts = false;

            var v = go.AddComponent<VerticalLayoutGroup>();
            v.childAlignment = TextAnchor.UpperLeft;
            v.padding = new RectOffset(24,24,24,24);
            v.spacing = 12f;

            var tGo = new GameObject("Title", typeof(RectTransform));
            var tRt = (RectTransform)tGo.transform; tRt.SetParent(existing, false);
            var t = tGo.AddComponent<TextMeshProUGUI>();
            t.text = "Fish";
            t.fontSize = 36; t.color = Color.white;
            t.alignment = TextAlignmentOptions.TopLeft;

            var bGo = new GameObject("Body", typeof(RectTransform));
            var bRt = (RectTransform)bGo.transform; bRt.SetParent(existing, false);
            var b = bGo.AddComponent<TextMeshProUGUI>();
            b.text = "";
            b.fontSize = 30; b.enableWordWrapping = true; b.color = Color.white;
            b.alignment = TextAlignmentOptions.TopLeft;

            var btnGo = new GameObject("Back", typeof(RectTransform), typeof(Image), typeof(Button));
            var btnRt = (RectTransform)btnGo.transform; btnRt.SetParent(existing, false);
            btnRt.sizeDelta = new Vector2(220, 48);
            var img = btnGo.GetComponent<Image>(); img.color = new Color(1,1,1,0.05f);
            var btn = btnGo.GetComponent<Button>(); btn.transition = Selectable.Transition.None;

            var btnTextGo = new GameObject("Text", typeof(RectTransform));
            var btnTextRt = (RectTransform)btnTextGo.transform; btnTextRt.SetParent(btnRt, false);
            btnTextRt.anchorMin = Vector2.zero; btnTextRt.anchorMax = Vector2.one;
            btnTextRt.offsetMin = Vector2.zero; btnTextRt.offsetMax = Vector2.zero;
            var btnTmp = btnTextGo.AddComponent<TextMeshProUGUI>();
            btnTmp.text = "BACK";
            btnTmp.alignment = TextAlignmentOptions.Center;
            btnTmp.fontSize = 26; btnTmp.color = Color.white;

            var view = go.AddComponent<InventoryDetailView>();
            view.group = cg; view.title = t; view.body = b; view.backButton = btn;
            return view;
        }
        else
        {
            return existing.GetComponent<InventoryDetailView>() ?? existing.gameObject.AddComponent<InventoryDetailView>();
        }
    }

    public void Show(string niceName, int registryId, System.Action onBack)
    {
        title.text = niceName;

        var sb = new StringBuilder(768);

        // ---- TOTAL CAUGHT (via InventoryService.All()) ----
        int total = 0;
        foreach (var (id, _, count) in InventoryService.All())
            if (id == registryId) { total = count; break; }

        sb.AppendLine($"Total caught: {total}");
        sb.AppendLine();

        // Helper to format the #1 line with cross-stats
        string CrossStats(InventoryStatsService.Record r, char mode)
        {
            return mode switch
            {
                'W' => $"1. {r.weightKg:0.###} kg (Q {r.quality}, L {r.lengthCm:0.#} cm)",
                'L' => $"1. {r.lengthCm:0.#} cm (Q {r.quality}, W {r.weightKg:0.###} kg)",
                'Q' => $"1. Q{r.quality} (W {r.weightKg:0.###} kg, L {r.lengthCm:0.#} cm)",
                _   => ""
            };
        }

        // WEIGHT
        sb.AppendLine($"Top {entriesPerList} â€” Weight (kg)");
        if (InventoryStatsService.TryGetWeightRecord(registryId, out var rw))
            sb.AppendLine("  " + CrossStats(rw, 'W'));
        else
            sb.AppendLine("  â€”  no records yet");
        sb.AppendLine();

        // LENGTH
        sb.AppendLine($"Top {entriesPerList} â€” Length (cm)");
        if (InventoryStatsService.TryGetLengthRecord(registryId, out var rl))
            sb.AppendLine("  " + CrossStats(rl, 'L'));
        else
            sb.AppendLine("  â€”  no records yet");
        sb.AppendLine();

        // QUALITY
        sb.AppendLine($"Top {entriesPerList} â€” Quality");
        if (InventoryStatsService.TryGetQualityRecord(registryId, out var rq))
            sb.AppendLine("  " + CrossStats(rq, 'Q'));
        else
            sb.AppendLine("  â€”  no records yet");
        sb.AppendLine();

        // BREEDING TANK
        sb.Append("BREEDING TANK: ");
        if (!InventoryStatsService.BreedingUnlocked)
        {
            sb.AppendLine("Breeding not yet unlocked");
        }
        else
        {
            var tank = InventoryStatsService.GetBreedingTank(registryId, 3);
            if (tank.Count == 0)
            {
                sb.AppendLine("(empty)");
            }
            else
            {
                sb.AppendLine();
                for (int i = 0; i < tank.Count; i++)
                {
                    var r = tank[i];
                    sb.AppendLine($"  â€¢ {niceName} â€” W {r.weightKg:0.###} kg, L {r.lengthCm:0.#} cm, Q {r.quality}");
                }
            }
        }

        body.text = sb.ToString();

        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => { onBack?.Invoke(); });

        group.alpha = 1f; group.interactable = true; group.blocksRaycasts = true;
        gameObject.SetActive(true);
    }

    public void Hide()
    {
        group.alpha = 0f; group.interactable = false; group.blocksRaycasts = false;
        gameObject.SetActive(false);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryFrameFitter.cs =====

using UnityEngine;
using UnityEngine.UI;

[ExecuteAlways]
public class InventoryFrameFitter : MonoBehaviour
{
    [Header("Refs")]
    public RectTransform windowRoot;   // InventoryWindow (RectTransform)
    public Image windowImage;          // Image on InventoryWindow (sliced sprite)
    public RectTransform header;       // InventoryWindow/Header
    public RectTransform body;         // InventoryWindow/Body
    public RectTransform scrollView;   // InventoryWindow/Body/ScrollView
    public RectTransform viewport;     // InventoryWindow/Body/ScrollView/Viewport
    public InventoryGridController grid;

    [Header("Layout")]
    public float extraMargin = 8f;     // extra space inside the neon rail
    public float headerHeight = 128f;  // visual height of the header strip

    [ContextMenu("Apply Layout Now")]
    public void Apply()
    {
        if (!windowRoot || !windowImage || !header || !body || !scrollView || !viewport)
            return;

        // Sprite.border is (Left, Right, Top, Bottom)
        Vector4 b = windowImage.sprite ? windowImage.sprite.border : new Vector4(64, 64, 64, 64);
        float left   = b.x + extraMargin; // L
        float right  = b.y + extraMargin; // R
        float top    = b.z + extraMargin; // T  (FIXED)
        float bottom = b.w + extraMargin; // B  (FIXED)

        // ----- Header (top strip inside the rail) -----
        header.anchorMin = new Vector2(0f, 1f);
        header.anchorMax = new Vector2(1f, 1f);
        header.pivot     = new Vector2(0.5f, 1f);
        header.offsetMin = new Vector2(left, -headerHeight); // left,  bottom (negative height)
        header.offsetMax = new Vector2(-right, -top);        // right, top

        // ----- Body (area below header, inside the rail) -----
        body.anchorMin = new Vector2(0f, 0f);
        body.anchorMax = new Vector2(1f, 1f);
        body.pivot     = new Vector2(0.5f, 0.5f);
        body.offsetMin = new Vector2(left, bottom);                 // left / bottom inside rail
        body.offsetMax = new Vector2(-right, -(top + headerHeight)); // right / top (reserve header)

        // ----- ScrollView fills Body -----
        scrollView.anchorMin = new Vector2(0f, 0f);
        scrollView.anchorMax = new Vector2(1f, 1f);
        scrollView.pivot     = new Vector2(0.5f, 0.5f);
        scrollView.offsetMin = Vector2.zero;
        scrollView.offsetMax = Vector2.zero;

        // ----- Viewport fills ScrollView -----
        viewport.anchorMin = new Vector2(0f, 0f);
        viewport.anchorMax = new Vector2(1f, 1f);
        viewport.pivot     = new Vector2(0f, 1f); // top-left so Content (0,1) aligns
        viewport.offsetMin = Vector2.zero;
        viewport.offsetMax = Vector2.zero;

        // Wire ScrollRect (if present) and refresh content size
        var sr = scrollView.GetComponent<ScrollRect>();
        if (sr)
        {
            sr.viewport = viewport;
            if (grid && grid.Content) sr.content = grid.Content;
            sr.horizontal = false;
            sr.vertical   = true;
            sr.movementType = ScrollRect.MovementType.Clamped;
            sr.scrollSensitivity = 30f;
        }

        if (grid) { grid.UpdateContentSize(); }
    }

    void OnEnable()  { Apply(); }
    void OnValidate(){ Apply(); }
    void OnRectTransformDimensionsChange()
    {
        if (isActiveAndEnabled) Apply();
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryGridController.cs =====

using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using GalacticFishing; // Fish, FishRegistry
// Uses FishMetaIndex to sort by FishMeta rarity at runtime

public class InventoryGridController : MonoBehaviour
{
    [Header("References")]
    public RectTransform Content;            // ScrollView/Viewport/Content
    public GridLayoutGroup Grid;             // on Content
    public InventorySlot SlotPrefab;         // Prefabs/UI/Slot_Prefab

    [Header("Fish Data")]
    public FishRegistry FishRegistry;        // Assign: Assets/Data/FishRegistry.asset
    public bool HideZeroItems = false;       // show zeros so ?-mark logic can run
    public bool DimZeroInsteadOfHide = true; // if zeros are shown, dim them

    [Header("Layout")]
    public int Columns = 13;                 // how many columns of slots
    public bool AutoSizeContent = true;
    public bool SnapScrollToTop = true;

    [Header("Sorting")]
    public InventorySortMode SortMode = InventorySortMode.OwnedFirst;

    [Header("Data")]
    public FishMetaIndex FishMetaIndex; // assign: Assets/Data/FishMetaIndex.asset

    [Header("Paging")]
    public bool UsePaging = true;
    [Tooltip("Visible rows per page (eg. 6 if you want a 6Ã—13=78 slot page).")]
    public int RowsPerPage = 6;

    [Header("Debug")]
    public bool GenerateDemoIfEmpty = false;
    public int DemoItemCount = 40;

    // backing store for ALL items (not a page slice)
    public List<ItemData> Items = new();

    // paging state
    public int Page { get; private set; } = 0;        // 0-based
    public int TotalPages { get; private set; } = 1;

    int PageSize => Mathf.Max(1, Columns * Mathf.Max(1, RowsPerPage));

    bool _subscribed;

    // Detail panel (built on first use)
    InventoryDetailView _detailView;

    void Awake()  => TryCacheRefs();

    void OnEnable()
    {
        TryCacheRefs();

        if (FishRegistry != null && !InventoryService.IsInitialized)
            InventoryService.Initialize(FishRegistry);

        if (!_subscribed)
        {
            InventoryService.OnChanged += HandleInventoryChanged;
            _subscribed = true;
        }

        // First build
        RebuildFromInventory();
    }

    void OnDisable()
    {
        if (_subscribed)
        {
            InventoryService.OnChanged -= HandleInventoryChanged;
            _subscribed = false;
        }
    }

    void OnValidate()
    {
        // keep numbers sane while editing
        Columns = Mathf.Max(1, Columns);
        RowsPerPage = Mathf.Max(1, RowsPerPage);
        if (UsePaging) ClampPage();
    }

    void HandleInventoryChanged() => RebuildFromInventory();

    public void SetSortMode(InventorySortMode mode)
    {
        if (SortMode == mode) return;
        SortMode = mode;
        RebuildFromInventory();
    }

    // ------- external paging API (used by InventoryPager) -------
    public void SetPage(int page)
    {
        if (!UsePaging) return;
        Page = Mathf.Clamp(page, 0, Mathf.Max(0, TotalPages - 1));
        Populate(); // draw the current page slice
    }

    public void PrevPage() => SetPage(Page - 1);
    public void NextPage() => SetPage(Page + 1);

    void ClampPage() => Page = Mathf.Clamp(Page, 0, Mathf.Max(0, TotalPages - 1));

    // ------- Public entry kept for existing callers -------
    public void Populate()
    {
        if (!Content || !SlotPrefab) return;

        // Clear
        for (int i = Content.childCount - 1; i >= 0; i--)
            Destroy(Content.GetChild(i).gameObject);

        if (UsePaging)
        {
            // slice the visible window
            int start = Page * PageSize;
            int end   = Mathf.Min(start + PageSize, Items.Count);

            for (int i = start; i < end; i++)
            {
                var slot = Instantiate(SlotPrefab, Content);
                slot.name = $"Slot_{i:000}";
                slot.Bind(Items[i]);
                slot.Clicked -= HandleSlotClicked; // avoid double subscription
                slot.Clicked += HandleSlotClicked;
            }
        }
        else
        {
            for (int i = 0; i < Items.Count; i++)
            {
                var slot = Instantiate(SlotPrefab, Content);
                slot.name = $"Slot_{i:000}";
                slot.Bind(Items[i]);
                slot.Clicked -= HandleSlotClicked;
                slot.Clicked += HandleSlotClicked;
            }
        }

        if (AutoSizeContent) UpdateContentSize();

        // Make sure first show starts at top
        if (SnapScrollToTop)
        {
            var sr = Content.GetComponentInParent<ScrollRect>();
            if (sr) sr.verticalNormalizedPosition = 1f;
        }
    }

    public void UpdateContentSize()
    {
        if (!Grid) return;

        int cols = Mathf.Max(1, Columns);
        int rows;
        if (UsePaging)
        {
            rows = Mathf.Max(1, RowsPerPage);
        }
        else
        {
            rows = Mathf.CeilToInt(Mathf.Max(1, Items.Count) / (float)cols);
        }

        float w = Grid.padding.left + Grid.padding.right
                + cols * Grid.cellSize.x + (cols - 1) * Grid.spacing.x;

        float h = Grid.padding.top + Grid.padding.bottom
                + rows * Grid.cellSize.y + (rows - 1) * Grid.spacing.y;

        Content.sizeDelta = new Vector2(w, h);
    }

    void TryCacheRefs()
    {
        if (!Content) Content = GetComponent<RectTransform>();
        if (!Grid && Content) Grid = Content.GetComponent<GridLayoutGroup>();
    }

    // ------- Build Items list from InventoryService + registry, then Populate() -------
    void RebuildFromInventory()
    {
        Items ??= new List<ItemData>();
        Items.Clear();

        if (!InventoryService.IsInitialized)
        {
            if (GenerateDemoIfEmpty)
            {
                // fallback demo
                for (int i = 0; i < DemoItemCount; i++)
                {
                    Items.Add(new ItemData { Icon = null, Count = Random.Range(0, 128), Rarity = Rarity.Common, Disabled = false, Tooltip = "Demo" });
                }
            }
            ComputeTotalPages();
            Populate();
            return;
        }

        // Owned-first ordering: bucket by count
        var owned = new List<ItemData>(128);
        var zeros = new List<ItemData>(128);

        foreach (var (id, fish, count) in InventoryService.All())
        {
            bool isZero = count <= 0;
            if (HideZeroItems && isZero) continue;

            FishMeta meta = null;
            if (FishMetaIndex && fish) meta = FishMetaIndex.FindByFish(fish);

            string label = GetLabelFromMetaOrFish(meta, fish);
            var rarityMapped = meta != null
                ? MapRarity(meta.rarity)
                : MapRarity(fish ? fish.rarity : FishRarity.Common);

            var data = new ItemData
            {
                // NEW: identity so click can open correct records
                RegistryId = id,
                FishDef    = fish,

                Icon       = fish ? fish.sprite : null,
                Count      = Mathf.Max(0, count),
                Disabled   = (!HideZeroItems && isZero) && DimZeroInsteadOfHide,
                Rarity     = rarityMapped,
                Tooltip    = label
            };

            if (isZero) zeros.Add(data);
            else        owned.Add(data);
        }

        ApplySorting(owned, zeros);

        ComputeTotalPages();
        Populate();
    }

    void ComputeTotalPages()
    {
        if (UsePaging)
        {
            int ps = Mathf.Max(1, PageSize);
            TotalPages = Mathf.Max(1, Mathf.CeilToInt(Items.Count / (float)ps));
            ClampPage();
        }
        else
        {
            TotalPages = 1;
            Page = 0;
        }
    }

    static Rarity MapRarity(FishRarity r) => r switch
    {
        FishRarity.Uncommon      => Rarity.Uncommon,
        FishRarity.Rare          => Rarity.Rare,
        FishRarity.Epic          => Rarity.Epic,
        FishRarity.Legendary     => Rarity.Legendary,
        FishRarity.UberLegendary => Rarity.Mythic,
        FishRarity.OneOfAKind    => Rarity.Mythic,
        _                        => Rarity.Common
    };

    // ---------- Records page ----------
    void HandleSlotClicked(InventorySlot slot)
    {
        var d = slot != null ? slot.Data : null;
        if (d == null || d.Count <= 0) return;

        // Build/find detail panel under the same frame that hosts the grid and pager.
        var contentFrame = Content ? Content.transform.parent as RectTransform : null; // Inventory-background/ContentFrame
        if (!_detailView && contentFrame) _detailView = InventoryDetailView.EnsureUnder(contentFrame);

        // Hide grid + pager while detail is shown
        ToggleGridAndPager(false, contentFrame);
        _detailView.Show(d.Tooltip, d.RegistryId, onBack: () =>
        {
            _detailView.Hide();
            ToggleGridAndPager(true, contentFrame);
        });
    }

    void ToggleGridAndPager(bool show, RectTransform contentFrame)
    {
        if (Content) Content.gameObject.SetActive(show);
        var pager = contentFrame ? contentFrame.Find("Pager") : null;
        if (pager) pager.gameObject.SetActive(show);
    }

    void ApplySorting(List<ItemData> owned, List<ItemData> zeros)
    {
        Items.Clear();
        switch (SortMode)
        {
            case InventorySortMode.OwnedFirst:
            case InventorySortMode.Quantity:
            {
                var all = owned.Concat(zeros)
                               .OrderByDescending(d => d.Count)
                               .ThenBy(NameKey);
                Items.AddRange(all);
                break;
            }
            case InventorySortMode.Name:
            {
                var all = owned.Concat(zeros).OrderBy(NameKey);
                Items.AddRange(all);
                break;
            }
            case InventorySortMode.Rarity:
            {
                var all = owned.Concat(zeros)
                               .OrderByDescending(GetRarityRank)
                               .ThenBy(NameKey);
                Items.AddRange(all);

                if (DebugSortLogs)
                {
                    try
                    {
                        var preview = Items.Take(10)
                                           .Select(d => $"{d.Tooltip} â€” rank {GetRarityRank(d)} (src:{GetSourceRarityName(d)})");
                        Debug.Log("[InventoryGridController] Rarity order (top 10):\n" + string.Join("\n", preview));
                    }
                    catch
                    {
                        // ignore errors when logging preview
                    }
                }
                break;
            }
        }
    }

    static string NameKey(ItemData data)
    {
        return (data?.Tooltip ?? string.Empty).Trim().ToLowerInvariant();
    }

    static string GetLabelFromMetaOrFish(FishMeta meta, Fish fish)
    {
        string dn = TryGetDisplayName(meta);
        if (!string.IsNullOrWhiteSpace(dn)) return dn;
        dn = TryGetDisplayName(fish);
        if (!string.IsNullOrWhiteSpace(dn)) return dn;
        return fish ? fish.name : "Unknown Fish";
    }

    static string TryGetDisplayName(object obj)
    {
        if (obj == null) return null;
        const BindingFlags BF = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase;
        var type = obj.GetType();
        var prop = type.GetProperty("DisplayName", BF) ?? type.GetProperty("displayName", BF);
        if (prop != null && prop.CanRead)
        {
            try { var value = prop.GetValue(obj, null) as string; if (!string.IsNullOrWhiteSpace(value)) return value; } catch { }
        }
        var field = type.GetField("DisplayName", BF) ?? type.GetField("displayName", BF);
        if (field != null)
        {
            try { var value = field.GetValue(obj) as string; if (!string.IsNullOrWhiteSpace(value)) return value; } catch { }
        }
        return null;
    }

    [Header("Debug (Sorting)")]
    public bool DebugSortLogs = false;

    int GetRarityRank(ItemData data)
    {
        // 1) Prefer FishMeta via index (source of truth).
        var fish = data != null ? data.FishDef : null;
        if (FishMetaIndex != null && fish != null)
        {
            var meta = FishMetaIndex.FindByFish(fish);
            if (meta != null)
            {
                return meta.rarity switch
                {
                    FishRarity.OneOfAKind    => 6,
                    FishRarity.UberLegendary => 5,
                    FishRarity.Legendary     => 4,
                    FishRarity.Epic          => 3,
                    FishRarity.Rare          => 2,
                    FishRarity.Uncommon      => 1,
                    _                        => 0,
                };
            }
        }

        // 2) Fallback to reflection for legacy defs.
        var rarityValue = TryGetMemberValueCI(fish, "rarity");
        if (rarityValue == null && fish != null)
        {
            foreach (var containerName in new[] { "meta", "fishMeta", "def", "definition", "data", "info" })
            {
                var container = TryGetMemberValueCI(fish, containerName);
                if (container == null) continue;
                rarityValue = TryGetMemberValueCI(container, "rarity");
                if (rarityValue != null) break;
            }
        }

        if (rarityValue != null)
        {
            return RankFromName(rarityValue.ToString());
        }

        return data != null ? CollapsedRarityRank(data.Rarity) : 0;
    }

    static int CollapsedRarityRank(Rarity rarity)
    {
        return rarity switch
        {
            Rarity.Mythic    => 5,
            Rarity.Legendary => 4,
            Rarity.Epic      => 3,
            Rarity.Rare      => 2,
            Rarity.Uncommon  => 1,
            _                => 0
        };
    }

    string GetSourceRarityName(ItemData data)
    {
        var fish = data != null ? data.FishDef : null;
        if (FishMetaIndex != null && fish != null)
        {
            var meta = FishMetaIndex.FindByFish(fish);
            if (meta != null) return meta.rarity.ToString();
        }
        if (fish == null) return "null";

        var value = TryGetMemberValueCI(fish, "rarity");
        if (value == null)
        {
            foreach (var containerName in new[] { "meta", "fishMeta", "def", "definition", "data", "info" })
            {
                var container = TryGetMemberValueCI(fish, containerName);
                if (container == null) continue;
                value = TryGetMemberValueCI(container, "rarity");
                if (value != null) break;
            }
        }
        return value != null ? value.ToString() : "n/a";
    }

    static object TryGetMemberValueCI(object target, string memberName)
    {
        if (target == null || string.IsNullOrEmpty(memberName)) return null;
        const BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase;

        var type = target.GetType();
        var prop = type.GetProperty(memberName, flags);
        if (prop != null)
        {
            try { return prop.GetValue(target); } catch { }
        }

        var field = type.GetField(memberName, flags);
        if (field != null)
        {
            try { return field.GetValue(target); } catch { }
        }

        return null;
    }

    static int RankFromName(string name)
    {
        if (string.IsNullOrEmpty(name)) return 0;
        var key = name.Replace(" ", string.Empty).ToLowerInvariant();
        return key switch
        {
            "oneofakind"    => 6,
            "uberlegendary" => 5,
            "legendary"     => 4,
            "epic"          => 3,
            "rare"          => 2,
            "uncommon"      => 1,
            _                => 0,
        };
    }
}

public enum InventorySortMode
{
    OwnedFirst = 0,
    Quantity   = 1,
    Name       = 2,
    Rarity     = 3
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryHoverName.cs =====

using TMPro;
using UnityEngine;

/// <summary>
/// Bezel hover label with a simple UI "lock":
/// - Inventory calls ShowUI/ClearUI while the cursor is over a slot.
/// - World code (if any) can call ShowWorld/ClearWorld, but it's ignored while UI is active.
/// Attach this to the TMP text you created for the inventory hover name.
/// </summary>
public class InventoryHoverName : MonoBehaviour
{
    [SerializeField] private TMP_Text label;
    [Tooltip("What to show when nothing is hovered. Leave empty to show nothing.")]
    [SerializeField] private string defaultText = "";

    private static InventoryHoverName _instance;
    private static int _uiHoverDepth = 0;   // >0 means UI has control

    void Awake()
    {
        if (!label) label = GetComponent<TMP_Text>();
    }

    void OnEnable()
    {
        _instance = this;
        Set(defaultText);
        _uiHoverDepth = 0;
    }

    void OnDisable()
    {
        if (_instance == this) _instance = null;
        _uiHoverDepth = 0;
    }

    // ---------- UI (inventory) API ----------
    public static void ShowUI(string text)
    {
        if (_instance == null) return;
        _uiHoverDepth++;
        _instance.Set(string.IsNullOrWhiteSpace(text) ? _instance.defaultText : text);
    }

    public static void ClearUI()
    {
        if (_instance == null) return;
        _uiHoverDepth = Mathf.Max(0, _uiHoverDepth - 1);
        if (_uiHoverDepth == 0) _instance.Set(_instance.defaultText);
    }

    // ---------- World (optional) API ----------
    public static void ShowWorld(string text)
    {
        if (_instance == null) return;
        if (_uiHoverDepth > 0) return; // UI has priority
        _instance.Set(text);
    }

    public static void ClearWorld()
    {
        if (_instance == null) return;
        if (_uiHoverDepth > 0) return; // UI has priority
        _instance.Set(_instance.defaultText);
    }

    // ---------- Internal ----------
    private void Set(string text)
    {
        if (!label) return;
        label.text = text ?? "";
        label.enabled = true;
        label.gameObject.SetActive(true);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryPager.cs =====

using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace GalacticFishing.UI
{
    /// Lightweight PREV / X/Y / NEXT pager for InventoryGridController.
    /// Put this on the same object as InventoryGridController (e.g., inventory-background).
    [DisallowMultipleComponent]
    [ExecuteAlways] // <- build/position in edit mode too
    public class InventoryPager : MonoBehaviour
    {
        [Header("Hook to your grid")]
        [SerializeField] private InventoryGridController grid;

        [Header("Build & Style")]
        [SerializeField] private bool   autoBuildUI  = true;
        [SerializeField] private Vector2 offset      = new Vector2(-280f, -400f); // what you liked
        [SerializeField] private float  spacing      = 24f;
        [SerializeField] private Vector2 buttonSize  = new Vector2(140f, 44f);
        [SerializeField] private string prevLabel    = "PREV <";
        [SerializeField] private string nextLabel    = "> NEXT";
        [SerializeField] private float  fontSize     = 24f;
        [SerializeField] private Color  textColor    = Color.white;
        [SerializeField] private Sprite buttonSprite = null;
        [SerializeField] private Color  buttonColor  = new Color(1f, 1f, 1f, 0f);

        [Header("Use existing UI (optional)")]
        [SerializeField] private Button   prevButton;
        [SerializeField] private TMP_Text pageText;
        [SerializeField] private Button   nextButton;

        // runtime/editor refs
        RectTransform pagerRT;
        HorizontalLayoutGroup hlg;

        void Awake()
        {
            HookGrid();
            if (autoBuildUI) EnsureUI();
            Wire();
            ApplyLayout();
            Refresh();
        }

        void OnEnable()
        {
            HookGrid();
            if (autoBuildUI) EnsureUI();
            Wire();
            ApplyLayout();
            Refresh();
        }

        // When values change in Inspector (edit mode), push to UI
        void OnValidate()
        {
            // Delay one frame in edit mode to let Unity serialize first-time values.
            if (!isActiveAndEnabled) return;
            HookGrid();
            if (autoBuildUI) EnsureUI();
            ApplyLayout();
            Refresh();
        }

        void HookGrid()
        {
            if (!grid)
            {
                grid = GetComponent<InventoryGridController>();
                if (!grid) grid = FindObjectOfType<InventoryGridController>();
            }
        }

        void EnsureUI()
        {
            if (!prevButton || !pageText || !nextButton || !pagerRT)
            {
                // Try to reuse an existing child called "Pager"
                var existing = transform.Find("Pager");
                if (existing)
                {
                    pagerRT = existing as RectTransform;
                    hlg     = pagerRT.GetComponent<HorizontalLayoutGroup>();
                    if (!hlg) hlg = pagerRT.gameObject.AddComponent<HorizontalLayoutGroup>();

                    // Attempt to pick up already-built children
                    if (!prevButton) prevButton = pagerRT.GetComponentInChildren<Button>(true);
                    if (!pageText)   pageText   = pagerRT.GetComponentInChildren<TMP_Text>(true);
                    if (!nextButton)
                    {
                        // If there was only one Button found, create the rest below
                        prevButton = null; pageText = null; nextButton = null;
                    }
                }

                if (!pagerRT)
                {
                    var parentRT = transform as RectTransform;
                    if (!parentRT) parentRT = gameObject.AddComponent<RectTransform>();

                    var rootGO = new GameObject("Pager", typeof(RectTransform));
                    pagerRT = (RectTransform)rootGO.transform;
                    pagerRT.SetParent(parentRT, false);
                    hlg = rootGO.AddComponent<HorizontalLayoutGroup>();
                }

                // (Re)build children if any are missing
                if (!prevButton || !pageText || !nextButton)
                {
                    // Clear children
                    for (int i = pagerRT.childCount - 1; i >= 0; i--)
                        DestroyImmediate(pagerRT.GetChild(i).gameObject);

                    prevButton = CreateTextButton("Prev", prevLabel, pagerRT);
                    pageText   = CreateLabel("Page", "1/1", pagerRT);
                    nextButton = CreateTextButton("Next", nextLabel, pagerRT);
                }
            }
        }

        Button CreateTextButton(string name, string label, RectTransform parent)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(Image), typeof(Button), typeof(LayoutElement));
            var rt = (RectTransform)go.transform;
            rt.SetParent(parent, false);

            var le = go.GetComponent<LayoutElement>();
            le.minWidth = buttonSize.x;  le.preferredWidth  = buttonSize.x;
            le.minHeight = buttonSize.y; le.preferredHeight = buttonSize.y;

            var img = go.GetComponent<Image>();
            img.sprite = buttonSprite;
            img.color  = buttonColor;
            img.raycastTarget = true;

            var btn = go.GetComponent<Button>();
            btn.targetGraphic = img;
            btn.transition    = Selectable.Transition.None;

            var txtGO = new GameObject("Text", typeof(RectTransform));
            var txtRT = (RectTransform)txtGO.transform;
            txtRT.SetParent(rt, false);
            txtRT.anchorMin = Vector2.zero; txtRT.anchorMax = Vector2.one;
            txtRT.offsetMin = Vector2.zero; txtRT.offsetMax = Vector2.zero;

            var tmp = txtGO.AddComponent<TextMeshProUGUI>();
            tmp.text = label;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.enableAutoSizing = false;
            tmp.fontSize = fontSize;
            tmp.color = textColor;
            tmp.enableWordWrapping = false;
            tmp.overflowMode = TextOverflowModes.Overflow;
            tmp.raycastTarget = false;

            return btn;
        }

        TMP_Text CreateLabel(string name, string label, RectTransform parent)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(LayoutElement));
            var rt = (RectTransform)go.transform;
            rt.SetParent(parent, false);

            var le = go.GetComponent<LayoutElement>();
            le.minWidth = 120f; le.preferredWidth  = 120f;
            le.minHeight = buttonSize.y; le.preferredHeight = buttonSize.y;

            var tmp = go.AddComponent<TextMeshProUGUI>();
            tmp.text = label;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.enableAutoSizing = false;
            tmp.fontSize = Mathf.Max(18f, fontSize * 0.8f);
            tmp.color = textColor;
            tmp.enableWordWrapping = false;
            tmp.overflowMode = TextOverflowModes.Overflow;
            tmp.raycastTarget = false;

            return tmp;
        }

        void ApplyLayout()
        {
            if (!pagerRT) return;

            // Anchor to bottom-center; use pivot Y=1 so negative Y moves upward (matches your hand tweak)
            pagerRT.anchorMin = new Vector2(0.5f, 0f);
            pagerRT.anchorMax = new Vector2(0.5f, 0f);
            pagerRT.pivot     = new Vector2(0.5f, 1f);
            pagerRT.anchoredPosition = offset;
            pagerRT.localScale = Vector3.one;

            if (!hlg) hlg = pagerRT.GetComponent<HorizontalLayoutGroup>();
            if (hlg)
            {
                hlg.childAlignment = TextAnchor.MiddleCenter;
                hlg.spacing = spacing;
                hlg.padding = new RectOffset(0, 0, 0, 0);
            }

            // Ensure button/label sizes reflect inspector values
            ResizeChild(prevButton);
            ResizeChild(nextButton);
        }

        void ResizeChild(Button btn)
        {
            if (!btn) return;
            var le = btn.GetComponent<LayoutElement>();
            if (!le) le = btn.gameObject.AddComponent<LayoutElement>();
            le.minWidth = buttonSize.x;  le.preferredWidth  = buttonSize.x;
            le.minHeight = buttonSize.y; le.preferredHeight = buttonSize.y;

            var tmp = btn.GetComponentInChildren<TextMeshProUGUI>(true);
            if (tmp)
            {
                tmp.fontSize = fontSize;
                tmp.color    = textColor;
            }
        }

        void Wire()
        {
            if (prevButton)
            {
                prevButton.onClick.RemoveAllListeners();
                prevButton.onClick.AddListener(OnPrev);
            }
            if (nextButton)
            {
                nextButton.onClick.RemoveAllListeners();
                nextButton.onClick.AddListener(OnNext);
            }
        }

        void OnPrev()
        {
            if (!grid) return;
            grid.PrevPage();
            Refresh();
        }

        void OnNext()
        {
            if (!grid) return;
            grid.NextPage();
            Refresh();
        }

        public void Refresh()
        {
            if (!grid) return;
            int cur = grid.Page + 1;
            int max = Mathf.Max(1, grid.TotalPages);
            if (pageText) pageText.text = cur.ToString() + "/" + max.ToString();
            if (prevButton) prevButton.interactable = (grid.Page > 0);
            if (nextButton) nextButton.interactable = (grid.Page < max - 1);
        }

        [ContextMenu("Rebuild Pager UI")]
        void RebuildNow()
        {
            EnsureUI();
            ApplyLayout();
            Wire();
            Refresh();
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryPlayBootstrap.cs =====

using UnityEngine;
using GalacticFishing;

public class InventoryPlayBootstrap : MonoBehaviour
{
    [SerializeField] InventoryGridController grid;
    [SerializeField] FishRegistry registry;
    [SerializeField] bool seedAddOneOfEveryFish = true;
    [SerializeField] bool onlyOncePerSession = true;

    const string SeedKey = "GF_INV_SEEDED_SESSION";

    void Awake()
    {
        if (!Application.isPlaying) return;
        if (!grid) grid = GetComponent<InventoryGridController>();
        if (!registry) registry = grid && grid.FishRegistry ? grid.FishRegistry : FindFirstObjectByType<FishRegistry>();
        if (!registry) { Debug.LogWarning("[InventoryPlayBootstrap] No FishRegistry found in scene."); return; }

        if (!InventoryService.IsInitialized) InventoryService.Initialize(registry);

        if (seedAddOneOfEveryFish && (!onlyOncePerSession || !PlayerPrefs.HasKey(SeedKey)))
        {
            for (int i = 0; i < registry.fishes.Count; i++)
                InventoryService.Set(i, 1);
            if (onlyOncePerSession)
                PlayerPrefs.SetInt(SeedKey, 1);
        }

        if (grid)
        {
            grid.FishRegistry = registry;
            grid.Populate();
        }

        var fixer = GetComponent<InventoryGridForceIcons>() ?? FindFirstObjectByType<InventoryGridForceIcons>();
        if (fixer) fixer.ApplyForce();
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventorySlot.cs =====

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;
using System.Linq;
using System;                 // <-- for Action
using GalacticFishing;        // <-- for Fish

public enum Rarity { Common, Uncommon, Rare, Epic, Legendary, Mythic }

[System.Serializable]
public class ItemData
{
    // NEW: identity info so a slot can open the right records page
    public int RegistryId = -1;     // index in FishRegistry (or -1 for non-fish items later)
    public Fish FishDef;            // optional reference to the Fish ScriptableObject

    public Sprite Icon;
    public int Count = 0;
    public Rarity Rarity = Rarity.Common;
    public bool Disabled = false;
    [TextArea] public string Tooltip; // pretty name
}

public class InventorySlot : MonoBehaviour,
    IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
{
    [Header("Wiring")]
    [SerializeField] private Image icon;
    [SerializeField] private TMP_Text countLabel;

    [Header("Optional Visuals")]
    [SerializeField] private CanvasGroup canvasGroup;   // for dimming/disable
    [SerializeField] private Image hoverGlow;           // optional
    [SerializeField] private Image pressedMask;         // optional
    [Header("Legacy/Compat (optional)")]
    [SerializeField] private Image frame;               // optional (for older utilities)
    [SerializeField] private Image disabledMask;        // optional (for older utilities)
    [SerializeField] private Image countBadge;          // optional badge under the count label
    [Header("Visuals")]
    [SerializeField] private Sprite zeroCountSprite;    // fallback sprite when empty

    [Header("Rarity (Optional ring swap)")]
    [SerializeField] private Image rarityRing;
    [SerializeField] private Sprite common, uncommon, rare, epic, legendary, mythic;

    [Header("Formatting")]
    [SerializeField] private bool useCompactNumbers = true;

    ItemData bound;
    public int CurrentCount => bound != null ? bound.Count : 0;

    // >>> NEW: expose the bound data for the grid <<<
    public ItemData Data => bound;

    // NEW: grid listens to this to open the Records page
    public Action<InventorySlot> Clicked;

    void Awake()
    {
        if (!icon) icon = GetComponentsInChildren<Image>(true).FirstOrDefault(i => i.name.ToLower().Contains("icon"));
        if (icon) { icon.preserveAspect = true; icon.raycastTarget = true; } // <-- make slot raycastable

        if (!countLabel) countLabel = GetComponentsInChildren<TMP_Text>(true).FirstOrDefault(t => t.name.ToLower().Contains("count"));
        if (countLabel) { countLabel.enabled = true; countLabel.gameObject.SetActive(true); countLabel.raycastTarget = false; }

        if (countBadge)
        {
            countBadge.raycastTarget = false;
            countBadge.enabled = true;
            if (countBadge.gameObject) countBadge.gameObject.SetActive(false);
        }

        if (hoverGlow)   hoverGlow.raycastTarget   = false;
        if (pressedMask) pressedMask.raycastTarget = false;
        if (disabledMask)disabledMask.raycastTarget= false;
        if (rarityRing)  rarityRing.raycastTarget  = false;
    }

    public InventorySlot Bind(ItemData data)
    {
        bound = data;

        if (icon)
        {
            if (data.Count <= 0)
            {
                icon.enabled = zeroCountSprite != null;
                icon.sprite = zeroCountSprite;
            }
            else
            {
                icon.enabled = data.Icon != null;
                if (data.Icon != null) icon.sprite = data.Icon;
            }
        }

        if (countLabel)
        {
            bool has = data.Count > 0;
            countLabel.text = has ? (useCompactNumbers ? Compact(data.Count) : Mathf.Max(0, data.Count).ToString()) : string.Empty;

            if (countBadge)
            {
                if (countBadge.gameObject) countBadge.gameObject.SetActive(has);
                countBadge.enabled = has;
            }
        }

        if (rarityRing)
        {
            rarityRing.enabled = true;
            rarityRing.sprite = data.Rarity switch
            {
                Rarity.Uncommon  => uncommon,
                Rarity.Rare      => rare,
                Rarity.Epic      => epic,
                Rarity.Legendary => legendary,
                Rarity.Mythic    => mythic,
                _                => common,
            };
        }

        if (hoverGlow)   hoverGlow.enabled   = false;
        if (pressedMask) pressedMask.enabled = false;
        if (disabledMask)disabledMask.enabled= false;
        ApplyDisabled(data.Disabled);
        return this;
    }

    public void SetIcon(Sprite sprite)
    {
        if (!icon) return;
        icon.enabled = sprite != null;
        icon.sprite = sprite;
    }

    static string Compact(int value)
    {
        if (value >= 1_000_000_000) return (value / 1_000_000_000f).ToString("0.#") + "b";
        if (value >= 1_000_000)     return (value / 1_000_000f).ToString("0.#") + "m";
        if (value >= 1_000)         return (value / 1_000f).ToString("0.#") + "k";
        return Mathf.Max(0, value).ToString();
    }

    void ApplyDisabled(bool disabled)
    {
        if (canvasGroup)
        {
            canvasGroup.alpha = disabled ? 0.33f : 1f;
            canvasGroup.interactable = !disabled;
            canvasGroup.blocksRaycasts = !disabled;
        }
        else
        {
            if (icon) icon.color = disabled ? new Color(1,1,1,0.33f) : Color.white;
            if (countLabel) countLabel.alpha = disabled ? 0.5f : 1f;
        }
        if (disabledMask) disabledMask.enabled = disabled;
    }

    // ----- Pointer events: UI has priority over world -----
    public void OnPointerEnter(PointerEventData _)
    {
        if (!IsDisabled() && hoverGlow) hoverGlow.enabled = true;

        if (bound != null && bound.Count > 0 && bound.Icon != null)
            InventoryHoverName.ShowUI(bound.Tooltip);
        else
            InventoryHoverName.ShowUI(""); // clears to default
    }

    public void OnPointerExit (PointerEventData _)
    {
        if (hoverGlow) hoverGlow.enabled = false;
        InventoryHoverName.ClearUI();
    }

    public void OnPointerDown (PointerEventData _){ if (!IsDisabled() && pressedMask) pressedMask.enabled = true; }

    public void OnPointerUp   (PointerEventData _)
    {
        if (pressedMask) pressedMask.enabled = false;

        // click-to-open (only if this slot actually represents at least one owned item)
        if (!IsDisabled() && bound != null && bound.Count > 0)
        {
            Clicked?.Invoke(this);
        }
    }

    bool IsDisabled() => bound != null && bound.Disabled;

    // Legacy accessors so older tools compile without changes.
    public Image Frame         => frame;
    public Image IconImage     => icon;
    public Image RarityRingImg => rarityRing;
    public Image PressedMaskImg=> pressedMask;
    public Image DisabledMask  => disabledMask;
    public TMP_Text CountText  => countLabel;
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventorySortDropdown.cs =====

using UnityEngine;
using TMPro;

[DisallowMultipleComponent]
public class InventorySortDropdown : MonoBehaviour
{
    [SerializeField] private InventoryGridController grid;
    [SerializeField] private TMP_Dropdown dropdown;
    [SerializeField] private bool autoFind = true;
    [SerializeField] private bool autoApplyOnStart = true;
    [SerializeField] private bool verbose = false;

    void Awake()
    {
        FindRefs();
        Wire(true);
        if (autoApplyOnStart) ApplyCurrent();
    }

    void OnEnable()
    {
        Wire(true);
        if (autoApplyOnStart) ApplyCurrent();
    }

    void OnDisable()
    {
        Wire(false);
    }

    void FindRefs()
    {
        if (autoFind)
        {
            if (!grid) grid = GetComponentInParent<InventoryGridController>(true);
            if (!dropdown) dropdown = GetComponent<TMP_Dropdown>() ?? GetComponentInChildren<TMP_Dropdown>(true);
        }
    }

    void Wire(bool enable)
    {
        if (!dropdown) return;
        dropdown.onValueChanged.RemoveListener(OnChanged);
        if (enable) dropdown.onValueChanged.AddListener(OnChanged);
    }

    void ApplyCurrent()
    {
        if (!dropdown) return;
        OnChanged(dropdown.value);
    }

    public void OnChanged(int index)
    {
        if (!grid || !dropdown) return;

        string label = index >= 0 && index < dropdown.options.Count
            ? dropdown.options[index].text
            : string.Empty;

        var key = label.Trim().ToLowerInvariant();
        InventorySortMode mode = key switch
        {
            "owned"     => InventorySortMode.OwnedFirst,
            "quantity"  => InventorySortMode.OwnedFirst, // treat old label as owned
            "rarity"    => InventorySortMode.Rarity,
            "name"      => InventorySortMode.Name,
            _           => InventorySortMode.OwnedFirst
        };

        if (verbose)
        {
            Debug.Log($"[InventorySortDropdown] Selected '{label}' -> {mode}");
        }

        grid.SetSortMode(mode);
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\InventoryWindowController.cs =====

using UnityEngine;
using UnityEngine.InputSystem;   // new input system keyboard API

public class InventoryWindowController : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private GameObject windowRoot;
    [SerializeField] private InventoryGridController grid;

    [Header("Background (optional)")]
    [Tooltip("CanvasGroup on the 'Inventory-background' object.")]
    [SerializeField] private CanvasGroup inventoryBackgroundGroup;

    [Header("Startup")]
    [SerializeField] private bool startOpen = false;

    [Header("Hotkey")]
    [SerializeField] private bool enableHotkey = true;
    [SerializeField] private Key hotkey = Key.I;

    private bool initialized;
    private bool _visible;

    private void Awake()
    {
        // Fallbacks so we never end up with a null root
        if (!windowRoot)
        {
            if (inventoryBackgroundGroup != null)
                windowRoot = inventoryBackgroundGroup.gameObject;
            else
                windowRoot = gameObject;
        }

        _visible = startOpen;

        Debug.Log("[InventoryWindowController] Awake on " + gameObject.name);
        ApplyVisibility(_visible);
    }

    private void OnEnable()
    {
        Debug.Log("[InventoryWindowController] OnEnable on " + gameObject.name);
    }

    private void Update()
    {
        var kb = Keyboard.current;
        if (kb == null)
        {
            // This would mean the new Input System isn't active at all.
            return;
        }

        if (!enableHotkey)
            return;

        // WATCH: I key (or whatever is set in the inspector)
        if (kb[hotkey].wasPressedThisFrame)
        {
            Debug.Log("[InventoryWindowController] Hotkey pressed: " + hotkey + " on " + gameObject.name);
            Toggle();
        }
    }

    // ---------- PUBLIC API (used by panel_hub button) ----------

    public void Show()  => ApplyVisibility(true);
    public void Hide()  => ApplyVisibility(false);

    /// <summary>
    /// Toggle between open/closed using our own _visible flag.
    /// This avoids depending on GameObject.activeSelf, which may not
    /// reflect whether the CanvasGroup is currently visible.
    /// </summary>
    public void Toggle()
    {
        ApplyVisibility(!_visible);
    }

    // ---------- INTERNAL ----------

    private void ApplyVisibility(bool visible)
    {
        _visible = visible;

        if (!windowRoot)
        {
            if (inventoryBackgroundGroup != null)
                windowRoot = inventoryBackgroundGroup.gameObject;
            else
                windowRoot = gameObject;
        }

        Debug.Log("[InventoryWindowController] ApplyVisibility(" + visible + ") on " + windowRoot.name);

        // Turn the whole window root on/off so OnEnable/OnDisable fire on children
        windowRoot.SetActive(visible);

        // Background CanvasGroup (if present) still controls fade and raycasts
        if (inventoryBackgroundGroup != null)
        {
            inventoryBackgroundGroup.alpha          = visible ? 1f : 0f;
            inventoryBackgroundGroup.interactable   = visible;
            inventoryBackgroundGroup.blocksRaycasts = visible;
        }

        // One-time grid initialization
        if (visible && !initialized && grid != null)
        {
            if (grid.FishRegistry && !InventoryService.IsInitialized)
                InventoryService.Initialize(grid.FishRegistry);

            grid.Populate();
            initialized = true;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\MenuRouter.cs =====

using UnityEngine;
using UnityEngine.InputSystem;
using GalacticFishing.UI;

public class MenuRouter : MonoBehaviour
{
    [Header("Inventory Window")]
    [SerializeField] private InventoryWindowController inventoryWindow;

    [Header("Inventory Views (inside Inventory-background)")]
    [Tooltip("The root that shows the normal 13x6 inventory view.")]
    [SerializeField] private GameObject contentFrame;

    [Tooltip("The root that shows the 2x4 card/upgrade view (CardviewRoot).")]
    [SerializeField] private GameObject cardviewRoot;

    [Header("Other UI Roots (optional)")]
    [SerializeField] private GameObject panelHub;     // Panel_Hub
    [SerializeField] private GameObject museumPanel;  // MuseumPanel (if used)

    // internal state
    private bool inventoryOpen;          // is the inventory window currently open?
    private bool inventoryOpenedFromHub; // did we open it from Panel_Hub?
    // true while Museum + 2x4 card view are open together
    private bool museumInventoryOpen = false;

    // Tracks which high-level screen is currently open.
    private enum MenuScreen
    {
        Gameplay,
        InventoryGrid,
        UpgradeCards,
        Museum,
        Hub
    }

    [SerializeField]
    private MenuScreen currentScreen = MenuScreen.Gameplay;

    private void Awake()
    {
        // We start with everything closed, world running.
        inventoryOpen        = false;
        inventoryOpenedFromHub = false;

        if (cardviewRoot != null)  cardviewRoot.SetActive(false);
        // contentFrame you probably want disabled at startup too â€“ do that in the scene if needed.
    }

    private void Update()
    {
        var kb = Keyboard.current;
        if (kb == null)
            return;

        if (kb[Key.Escape].wasPressedThisFrame)
        {
            HandleEscape();
        }
    }

    // --------------------------------------------------------------------
    // PUBLIC API â€“ call these from buttons / quickbar
    // --------------------------------------------------------------------

    /// <summary>Open inventory while you are inside the Hub (Panel_Hub).</summary>
    public void OpenInventoryFromHub()
    {
        inventoryOpenedFromHub = true;
        OpenInventoryGrid();
    }

    /// <summary>Open inventory directly from the world (Quickbar, future hotkey, etc).</summary>
    public void OpenInventoryFromWorld()
    {
        inventoryOpenedFromHub = false;
        OpenInventoryGrid();
    }

    public void OpenInventoryGrid()
    {
        Debug.Log("[MenuRouter] OpenInventoryGrid()");

        if (panelHub != null)
            panelHub.SetActive(false);

        if (museumPanel != null)
            museumPanel.SetActive(false);

        if (inventoryWindow != null)
            inventoryWindow.Show();

        if (contentFrame != null)
            contentFrame.SetActive(true);

        if (cardviewRoot != null)
            cardviewRoot.SetActive(false);

        inventoryOpen = true;
        museumInventoryOpen = false;
        currentScreen = MenuScreen.InventoryGrid;
    }

    /// <summary>Open the upgrade cards screen.</summary>
    public void OpenUpgradeCards()
    {
        Debug.Log("[MenuRouter] OpenUpgradeCards()");

        if (panelHub != null)
            panelHub.SetActive(false);

        if (museumPanel != null)
            museumPanel.SetActive(false);

        if (inventoryWindow != null)
            inventoryWindow.Show();

        if (contentFrame != null)
            contentFrame.SetActive(false);

        if (cardviewRoot != null)
            cardviewRoot.SetActive(true);

        inventoryOpen = true;
        museumInventoryOpen = false;
        currentScreen = MenuScreen.UpgradeCards;
    }

    public void OpenMuseumSell()
    {
        // We are entering the Museum Sell view:
        // - Hide the hub
        // - Show museum backdrop
        // - Open the inventory window, but with 2x4 cards instead of the 13x6 grid
        museumInventoryOpen = true;

        if (panelHub != null)
            panelHub.SetActive(false);

        if (museumPanel != null)
            museumPanel.SetActive(true);

        if (inventoryWindow != null)
            inventoryWindow.Show();

        if (contentFrame != null)
            contentFrame.SetActive(false);

        if (cardviewRoot != null)
            cardviewRoot.SetActive(true);

        inventoryOpen = true;
        currentScreen = MenuScreen.Museum;
    }

    private void HandleEscape()
    {
        switch (currentScreen)
        {
            case MenuScreen.InventoryGrid:
            case MenuScreen.UpgradeCards:
            case MenuScreen.Museum:
            case MenuScreen.Hub:
                CloseAllAndReturnToGameplay();
                break;

            case MenuScreen.Gameplay:
            default:
                break;
        }
    }

    private void CloseAllAndReturnToGameplay()
    {
        Debug.Log("[MenuRouter] CloseAllAndReturnToGameplay()");

        if (inventoryWindow != null)
            inventoryWindow.Hide();

        if (contentFrame != null)
            contentFrame.SetActive(false);

        if (cardviewRoot != null)
            cardviewRoot.SetActive(false);

        if (panelHub != null)
            panelHub.SetActive(false);

        if (museumPanel != null)
            museumPanel.SetActive(false);

        inventoryOpen = false;
        inventoryOpenedFromHub = false;
        museumInventoryOpen = false;
        currentScreen = MenuScreen.Gameplay;

        // Make sure the world is actually running again.
        ResetGameplayState();
    }

    /// <summary>
    /// Ensure the world is un-paused and gameplay block flag is cleared.
    /// Call this whenever we fully return to gameplay (no menus open).
    /// </summary>
    private void ResetGameplayState()
    {
        if (Time.timeScale != 1f)
            Time.timeScale = 1f;

        // Clear any global gameplay-block flag set by UIBlocksGameplay.
        UIBlocksGameplay.GameplayBlocked = false;
    }

    /// <summary>One-step back navigation, driven by Escape.</summary>
    public void Back()
    {
        if (museumInventoryOpen)
        {
            // Leaving the Museum Sell view: close cards, close museum, return to hub
            museumInventoryOpen = false;

            if (inventoryWindow != null)
                inventoryWindow.Hide();

            if (cardviewRoot != null)
                cardviewRoot.SetActive(false);

            if (museumPanel != null)
                museumPanel.SetActive(false);

            if (panelHub != null)
                panelHub.SetActive(true);

            currentScreen = MenuScreen.Hub;
            return;
        }

        // 1) If inventory is open, that is always top of the stack.
        if (inventoryOpen)
        {
            CloseInventory();

            if (inventoryOpenedFromHub && panelHub != null)
            {
                // We came from Hub -> Inventory, so go back to Hub.
                panelHub.SetActive(true);
                currentScreen = MenuScreen.Hub;
            }
            else
            {
                // We came directly from gameplay.
                currentScreen = MenuScreen.Gameplay;
                ResetGameplayState();
            }

            return;
        }

        // 2) No inventory â€“ next priority: close Museum if it is open.
        if (museumPanel != null && museumPanel.activeSelf)
        {
            museumPanel.SetActive(false);
            currentScreen = MenuScreen.Gameplay;
            ResetGameplayState();
            return;
        }

        // 3) Finally, if Hub is open, close it to go back to world.
        if (panelHub != null && panelHub.activeSelf)
        {
            panelHub.SetActive(false);
            currentScreen = MenuScreen.Gameplay;
            ResetGameplayState();
            return;
        }

        // 4) Nothing to close -> already in world.
    }

    // --------------------------------------------------------------------
    // INTERNAL HELPERS
    // --------------------------------------------------------------------

    private void CloseInventory()
    {
        if (inventoryWindow != null)
            inventoryWindow.Hide();

        inventoryOpen = false;

        // Hide both views â€“ the next screen we go to will decide what to show.
        if (contentFrame != null)
            contentFrame.SetActive(false);

        if (cardviewRoot != null)
            cardviewRoot.SetActive(false);

        // If we did NOT come from Hub, then closing inventory means go back to world UI.
        if (!inventoryOpenedFromHub && panelHub != null)
        {
            // We *don't* reopen the hub in this case â€“ we came from the world.
            // World just continues running; Hub stays as it was (usually disabled).
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\QuickBarController.cs =====

using UnityEngine;
using UnityEngine.UI;

public enum QuickBarAction
{
    None,
    InventoryGrid,
    UpgradeCards
}

[System.Serializable]
public class QuickBarSlot
{
    public Button button;
    public QuickBarAction action;
}

public class QuickBarController : MonoBehaviour
{
    [Header("Routing")]
    [SerializeField] private MenuRouter menuRouter;

    [Header("Slots")]
    [SerializeField] private QuickBarSlot[] slots;

    private void Awake()
    {
        if (menuRouter == null)
        {
            Debug.LogWarning("[QuickBarController] MenuRouter is not assigned.");
            return;
        }

        foreach (var slot in slots)
        {
            if (slot == null || slot.button == null)
                continue;

            QuickBarAction action = slot.action; // capture local copy
            slot.button.onClick.AddListener(() => ActivateSlot(action));
        }
    }

    private void ActivateSlot(QuickBarAction action)
    {
        switch (action)
        {
            case QuickBarAction.InventoryGrid:
                // Direct world -> inventory
                menuRouter.OpenInventoryFromWorld();
                break;

            case QuickBarAction.UpgradeCards:
                menuRouter.OpenUpgradeCards();
                break;

            case QuickBarAction.None:
            default:
                // Unassigned slot
                break;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\ReactionBarController.cs =====

using UnityEngine;

namespace GalacticFishing.UI
{
    public class ReactionBarController : MonoBehaviour
    {
        [Header("Assign the parent GameObject that contains the bar UI")]
        [SerializeField] private GameObject reactionBarRoot;

        [Header("Optional fade (CanvasGroup on the same root)")]
        [SerializeField] private float fadeDuration = 0.12f;

        private CanvasGroup _cg;
        private bool _isVisible;

        private void Awake()
        {
            if (reactionBarRoot == null)
            {
                Debug.LogError("[ReactionBarController] ReactionBarRoot is not assigned.");
                enabled = false;
                return;
            }

            _cg = reactionBarRoot.GetComponent<CanvasGroup>();
            if (_cg == null)
            {
                // Add one for quick fades (safe if you forgot)
                _cg = reactionBarRoot.AddComponent<CanvasGroup>();
            }

            // Start hidden
            reactionBarRoot.SetActive(false);
            _cg.alpha = 0f;
            _isVisible = false;
        }

        private void Update()
        {
            // Show on left-click or Space
            if (Input.GetMouseButtonDown(0) || Input.GetKeyDown(KeyCode.Space))
            {
                ShowBar();
            }

            // Press Escape to hide (handy while testing)
            if (Input.GetKeyDown(KeyCode.Escape))
            {
                HideBar();
            }
        }

        public void ShowBar()
        {
            if (_isVisible) return;
            reactionBarRoot.SetActive(true);
            _isVisible = true;
            StopAllCoroutines();
            StartCoroutine(FadeTo(1f, fadeDuration));
        }

        public void HideBar()
        {
            if (!_isVisible) return;
            _isVisible = false;
            StopAllCoroutines();
            StartCoroutine(FadeOutAndDeactivate());
        }

        private System.Collections.IEnumerator FadeTo(float target, float duration)
        {
            float start = _cg.alpha;
            float t = 0f;
            while (t < duration)
            {
                t += Time.unscaledDeltaTime;
                _cg.alpha = Mathf.Lerp(start, target, Mathf.Clamp01(t / duration));
                yield return null;
            }
            _cg.alpha = target;
        }

        private System.Collections.IEnumerator FadeOutAndDeactivate()
        {
            yield return FadeTo(0f, fadeDuration);
            reactionBarRoot.SetActive(false);
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\ReactionBarTrack.cs =====

using UnityEngine;
using UnityEngine.UI;

namespace GalacticFishing.UI
{
    [ExecuteAlways]
    public class ReactionBarTrack : MonoBehaviour
    {
        [Header("Assign")]
        [SerializeField] private RectTransform barRect;   // required
        [SerializeField] private Image barImage;          // optional (Sliced sprite)

        [Header("Inner Edges")]
        [SerializeField] private bool useSpriteBorder = true;
        [SerializeField] private float leftInsetPercent  = 0f;
        [SerializeField] private float rightInsetPercent = 0f;
        [SerializeField] private float extraLeftPx = 0f;
        [SerializeField] private float extraRightPx = 0f;
        [SerializeField] private float extraTopPx = 0f;
        [SerializeField] private float extraBottomPx = 0f;

        [Header("Vertical Center")]
        [SerializeField] private float yCenterNudgePx = 0f;

        private float _innerLeftX, _innerRightX, _centerY;
        private float _innerTopY, _innerBottomY;
        private static readonly Vector3[] _corners = new Vector3[4];

        public bool IsValid => barRect != null;
        public float InnerLeftX   => _innerLeftX;
        public float InnerRightX  => _innerRightX;
        public float CenterY      => _centerY;
        public float InnerTopY    => _innerTopY;
        public float InnerBottomY => _innerBottomY;
        public float InnerHeightWorld => _innerTopY - _innerBottomY;

        private void OnEnable() { Recompute(); }
        private void Update() { Recompute(); }
        private void OnRectTransformDimensionsChange() { Recompute(); }

        public void Recompute()
        {
            if (!barRect) return;

            barRect.GetWorldCorners(_corners); // 0=BL,1=TL,2=TR,3=BR
            float leftX   = _corners[0].x, rightX = _corners[2].x;
            float bottomY = _corners[0].y, topY   = _corners[1].y;
            float widthW  = rightX - leftX;

            // Sprite border (px -> world)
            float insetLw = 0f, insetRw = 0f, insetTw = 0f, insetBw = 0f;
            if (useSpriteBorder && barImage && barImage.type == Image.Type.Sliced && barImage.sprite)
            {
                var border = barImage.sprite.border;
                float ppu  = barImage.sprite.pixelsPerUnit > 0 ? barImage.sprite.pixelsPerUnit : 100f;
                insetLw = (border.x / ppu) * barRect.lossyScale.x;
                insetRw = (border.z / ppu) * barRect.lossyScale.x;
                insetTw = (border.y / ppu) * barRect.lossyScale.y;
                insetBw = (border.w / ppu) * barRect.lossyScale.y;
            }

            // Percent insets (negative allowed)
            float percLw = widthW * leftInsetPercent;
            float percRw = widthW * rightInsetPercent;

            // Extra px -> world
            insetLw += extraLeftPx   * barRect.lossyScale.x;
            insetRw += extraRightPx  * barRect.lossyScale.x;
            insetTw += extraTopPx    * barRect.lossyScale.y;
            insetBw += extraBottomPx * barRect.lossyScale.y;

            _innerLeftX  = leftX  + insetLw + percLw;
            _innerRightX = rightX - insetRw - percRw;

            _innerTopY    = topY    - insetTw;
            _innerBottomY = bottomY + insetBw;

            float center = (_innerTopY + _innerBottomY) * 0.5f;
            _centerY = center + (yCenterNudgePx * barRect.lossyScale.y);
        }

        public float NormalizedToWorldX(float u01) =>
            Mathf.Lerp(_innerLeftX, _innerRightX, Mathf.Clamp01(u01));

        public float WorldXToNormalized(float worldX)
        {
            float w = _innerRightX - _innerLeftX;
            if (Mathf.Approximately(w, 0f)) return 0f;
            return Mathf.Clamp01((worldX - _innerLeftX) / w);
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\ReactionBarUI.cs =====

using UnityEngine;

namespace GalacticFishing.UI
{
    [DisallowMultipleComponent]
    public class ReactionBarUI : MonoBehaviour
    {
        [Header("Assign")]
        [SerializeField] private ReactionBarTrack track;
        [SerializeField] private RectTransform markerRect;

        [Header("Motion")]
        [SerializeField] private float speed = 1.2f;

        [Header("Horizontal Insets (of inner width)")]
        [SerializeField] private float leftInsetPercentInner  = 0f;
        [SerializeField] private float rightInsetPercentInner = 0f;

        [Header("Clamp (optional)")]
        [SerializeField] private bool clampByWidth = false;
        [SerializeField] private float clampWidthPx = 24f;
        [SerializeField] private float extraClampMarginPx = 0f;

        [Header("Vertical Alignment")]
        [SerializeField] private bool  lockYToTrackCenter = true;
        [Tooltip("Marker-only Y offset in SCREEN pixels (resolution-proof). +up / -down")]
        [SerializeField] private float yNudgePx = 0f;

        // runtime
        private bool _running;
        private float _t;
        private int _dir = 1;

        private static float CanvasScaleFactor(Component c)
        {
            var canvas = c.GetComponentInParent<Canvas>();
            return canvas ? Mathf.Max(0.0001f, canvas.scaleFactor) : 1f;
        }

        private void Update()
        {
            if (!_running || track == null || markerRect == null || !track.IsValid) return;

            // ping-pong motion (unscaled time so pause doesn't stop the marker)
            _t += _dir * Mathf.Max(0f, speed) * Time.unscaledDeltaTime;
            if (_t > 1f) { _t = 1f; _dir = -1; }
            else if (_t < 0f) { _t = 0f; _dir = 1; }

            // inner edges (WORLD)
            float L = track.InnerLeftX;
            float R = track.InnerRightX;
            float innerW = Mathf.Max(0.0001f, R - L);

            // travel insets (percent of inner width)
            if (leftInsetPercentInner > 0f || rightInsetPercentInner > 0f)
            {
                L += innerW * Mathf.Clamp01(leftInsetPercentInner);
                R -= innerW * Mathf.Clamp01(rightInsetPercentInner);
            }

            // clamp by tip width, if enabled
            if (clampByWidth)
            {
                float sx = Mathf.Abs(markerRect.lossyScale.x);
                float half = (Mathf.Abs(clampWidthPx) * sx) * 0.5f + (extraClampMarginPx * sx);
                L += half; R -= half; if (R < L) R = L;
            }

            // apply world pos
            Vector3 wpos = markerRect.position;
            wpos.x = Mathf.Lerp(L, R, _t);

            if (lockYToTrackCenter)
            {
                float sf = CanvasScaleFactor(markerRect);
                float yWorldNudge = yNudgePx / sf;
                wpos.y = track.CenterY + yWorldNudge;
            }

            markerRect.position = wpos;
        }

        // -------- Public API (controller-only) --------
        public void StartRun()
        {
            _running = true;
            _t = 0f;
            _dir = 1;
        }

        public void StopRun()
        {
            _running = false;
        }

        /// <summary>Marker normalized X across track inner width [0..1].</summary>
        public float MarkerNormalized01()
        {
            if (track == null || markerRect == null || !track.IsValid) return 0f;
            float L = track.InnerLeftX;
            float R = track.InnerRightX;
            float W = Mathf.Max(0.0001f, R - L);
            float x = markerRect.position.x;
            return Mathf.Clamp01((x - L) / W);
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\ShowReactionBar_InputSystem.cs =====

using UnityEngine;
using UnityEngine.InputSystem; // NEW input system

public class ShowReactionBar_InputSystem : MonoBehaviour
{
    [SerializeField] private GameObject reactionBarRoot;  // assign ReactionBar
    [SerializeField] private CanvasGroup reactionBarCG;    // assign its CanvasGroup
    [SerializeField] private bool toggleInsteadOfShow = false; // optional

    private InputAction _startAction;

    private void Awake()
    {
        _startAction = new InputAction("StartReaction");
        _startAction.AddBinding("<Mouse>/leftButton");
        _startAction.AddBinding("<Keyboard>/space");

        if (reactionBarRoot) reactionBarRoot.SetActive(false); // hidden on start
        if (reactionBarCG) reactionBarCG.alpha = 0f;
    }

    private void OnEnable()  { _startAction.Enable(); }
    private void OnDisable() { _startAction.Disable(); }

    private void Update()
    {
        if (_startAction.triggered)
        {
            if (toggleInsteadOfShow)
            {
                bool next = !reactionBarRoot.activeSelf;
                reactionBarRoot.SetActive(next);
                if (reactionBarCG) reactionBarCG.alpha = next ? 1f : 0f;
            }
            else
            {
                reactionBarRoot.SetActive(true);
                if (reactionBarCG) reactionBarCG.alpha = 1f;
            }
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\TileHoverRelay.cs =====

using UnityEngine;
using UnityEngine.EventSystems;

namespace GalacticFishing.UI
{
    [AddComponentMenu("Galactic Fishing/UI/Tile Hover Relay")]
    public sealed class TileHoverRelay : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        public HubHoverHint hint;
        [TextArea] public string text;

        public void OnPointerEnter(PointerEventData eventData) { if (hint) hint.Set(text); }
        public void OnPointerExit(PointerEventData eventData)  { if (hint) hint.Clear(); }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\UIBlocksGameplay.cs =====

using UnityEngine;

namespace GalacticFishing.UI
{
    [DisallowMultipleComponent]
    public class UIBlocksGameplay : MonoBehaviour
    {
        [Header("Detect inventory visibility (optional)")]
        public CanvasGroup inventoryCanvasGroup;   // drag the Inventory-background CanvasGroup here

        [Header("Disable while inventory is open")]
        public GameObject[] objectsToDisable;      // drag WHOLE scene objects here (HookCard, ReactionBar, etc.)
        public Behaviour[] behavioursToDisable;    // or drag specific components (e.g., HookCardService)

        [Header("Optional global flag other scripts can read")]
        public bool setGlobalBlockFlag = true;
        public static bool GameplayBlocked;

        bool _lastOpen;

        void Awake()
        {
            if (!inventoryCanvasGroup)
                inventoryCanvasGroup = GetComponent<CanvasGroup>();
        }

        void OnEnable()  => ApplyIfChanged();
        void Update()    => ApplyIfChanged();

        void ApplyIfChanged()
        {
            bool open = IsInventoryOpen();
            if (open == _lastOpen) return;
            _lastOpen = open;

            if (objectsToDisable != null)
                foreach (var go in objectsToDisable) if (go) go.SetActive(!open);

            if (behavioursToDisable != null)
                foreach (var b in behavioursToDisable) if (b) b.enabled = !open;

            if (setGlobalBlockFlag) GameplayBlocked = open;
        }

        bool IsInventoryOpen()
        {
            if (!gameObject.activeInHierarchy) return false;
            if (inventoryCanvasGroup)
                return inventoryCanvasGroup.alpha > 0.5f && inventoryCanvasGroup.blocksRaycasts;
            // fallback if no CanvasGroup was set
            return true;
        }
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\UiCanvasConfig.cs =====

using UnityEngine;
using UnityEngine.UI;

public enum UiCanvasCategory { HUD = 0, Panel = 50, Menu = 100, Popup = 200, Top = 1000 }

[DisallowMultipleComponent]
[RequireComponent(typeof(Canvas))]
[RequireComponent(typeof(GraphicRaycaster))]
public class UICanvasConfig : MonoBehaviour
{
    public UiCanvasCategory category = UiCanvasCategory.Menu;
    public Vector2 referenceResolution = new Vector2(1920, 1080);
    [Range(0f,1f)] public float matchWidthOrHeight = 0.5f;
    public bool bringToFrontOnEnable = true;
    public int orderOffset = 0;

    Canvas canvas;

    void Reset()
    {
        canvas = GetComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvas.overrideSorting = true;

        var scaler = GetComponent<CanvasScaler>() ?? gameObject.AddComponent<CanvasScaler>();
        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
        scaler.referenceResolution = referenceResolution;
        scaler.matchWidthOrHeight = matchWidthOrHeight;
    }

    void Awake()
    {
        canvas = GetComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvas.overrideSorting = true;

        var scaler = GetComponent<CanvasScaler>() ?? gameObject.AddComponent<CanvasScaler>();
        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
        scaler.referenceResolution = referenceResolution;
        scaler.matchWidthOrHeight = matchWidthOrHeight;
    }

    void OnEnable()
    {
        if (bringToFrontOnEnable) UiSorting.BringToFront(GetComponent<Canvas>(), category, orderOffset);
    }

    public void BringToFront() => UiSorting.BringToFront(GetComponent<Canvas>(), category, orderOffset);
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\UiSorting.cs =====

using System.Collections.Generic;
using UnityEngine;

public static class UiSorting
{
    static readonly Dictionary<UiCanvasCategory,int> _top = new();

    static int Base(UiCanvasCategory cat) => (int)cat;

    public static int Next(UiCanvasCategory cat)
    {
        if (!_top.TryGetValue(cat, out var cur)) cur = Base(cat);
        cur += 1;
        _top[cat] = cur;
        return cur;
    }

    public static void BringToFront(Canvas c, UiCanvasCategory cat, int offset = 0)
    {
        if (!c) return;
        c.overrideSorting = true;
        c.sortingOrder = Next(cat) + offset;
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HookCard\FitFishToHookCard.cs =====

using UnityEngine;

public class FitFishToHookCard : MonoBehaviour
{
    [Header("Refs")]
    public HookCardUI hookCard;            // HookCard (root) here
    public RectTransform fishRect;         // Big fish RectTransform (BeepFish)

    [Header("Content margins inside the panel (pixels)")]
    public float left = 120f;
    public float right = 120f;
    public float top = 150f;
    public float bottom = 170f;

    [Header("Layout")]
    [Range(0.6f, 1f)] public float fill = 0.92f; // % of the available square to use
    public float yNudge = 12f;                   // small upward bias in panel space (pixels)

    // original state
    Vector2 _origSize;
    Vector3 _origPos;
    Vector2 _origAnchorMin, _origAnchorMax;
    Vector2 _origPivot;
    bool _saved, _fitted;

    void Reset()
    {
        fishRect = GetComponent<RectTransform>();
    }

    void LateUpdate()
    {
        if (!hookCard || !hookCard.panelRect || !fishRect) return;

        // Card hidden? restore once and bail
        if (!hookCard.gameObject.activeInHierarchy)
        {
            if (_fitted) Restore();
            return;
        }

        if (!_saved) SaveOriginal();

        // Panel content box (subtract asymmetric margins)
        var r = hookCard.panelRect.rect;
        float contentW = Mathf.Max(0f, r.width  - (left + right));
        float contentH = Mathf.Max(0f, r.height - (top  + bottom));
        float target = Mathf.Min(contentW, contentH) * fill;

        // Size fish (square; make sure fish Image has Preserve Aspect ON)
        fishRect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, target);
        fishRect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical,   target);

        // Center + Y nudge in panel local, then convert to world
        var localCenter = new Vector3(r.center.x, r.center.y + yNudge, 0f);
        Vector3 worldCenter = hookCard.panelRect.TransformPoint(localCenter);
        fishRect.position = worldCenter;

        _fitted = true;
    }

    void SaveOriginal()
    {
        _origSize      = fishRect.rect.size;
        _origPos       = fishRect.position;
        _origAnchorMin = fishRect.anchorMin; _origAnchorMax = fishRect.anchorMax;
        _origPivot     = fishRect.pivot;
        _saved         = true;
    }

    void Restore()
    {
        fishRect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, _origSize.x);
        fishRect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical,   _origSize.y);
        fishRect.position  = _origPos;
        fishRect.anchorMin = _origAnchorMin; fishRect.anchorMax = _origAnchorMax;
        fishRect.pivot     = _origPivot;
        _fitted            = false;
    }
}

// ===== FILE: F:\Coding\Gfishing v0.02\Assets\Scripts\UI\HookCard\HookCardService.cs =====

using UnityEngine;
using System;
using System.Collections;
using Object = UnityEngine.Object;

/// <summary>
/// Central service for the Hook Card overlay.
/// - Auto-finds HookCardUI even if inactive or in another canvas.
/// - Keeps existing API working: ShowInProgress/ShowCaught/ShowEscaped.
/// - Adds global hold times so âœ“/âœ• stay visible consistently.
/// </summary>
[DefaultExecutionOrder(-100)]
public class HookCardService : MonoBehaviour
{
    [SerializeField] private HookCardUI ui;  // optional direct reference

    private static HookCardService _i;
    private static bool _warned;

    // ------- configurable holds (edit these or set at runtime) -------
    public static float CaughtHoldSeconds  = 2f;   // âœ“ visible time
    public static float EscapedHoldSeconds = 2f;   // âœ• visible time
    // -----------------------------------------------------------------

    // Events so other systems (e.g., future UI or analytics) can react to overlay changes.
    public static event Action<HookState> OverlayShown;
    public static event Action OverlayHidden;

    private static HookCardService I
    {
        get
        {
            if (_i != null) return _i;
            _i = Object.FindObjectOfType<HookCardService>(true);
            if (_i != null) return _i;
            var go = new GameObject("HookCardService (auto)");
            Object.DontDestroyOnLoad(go);
            _i = go.AddComponent<HookCardService>();
            return _i;
        }
    }

    private void Awake()
    {
        if (_i == null) _i = this;
        else if (_i != this) { Destroy(gameObject); return; }
        TryBindUI();
    }

    private bool TryBindUI()
    {
        if (ui) return true;

        ui = Object.FindObjectOfType<HookCardUI>(true);
        if (ui) return true;

        var all = Resources.FindObjectsOfTypeAll<HookCardUI>();
        if (all != null && all.Length > 0) { ui = all[0]; return true; }

        if (!_warned)
        {
            _warned = true;
            Debug.LogWarning("[HookCardService] No HookCardUI found in scene.");
        }
        return false;
    }

    // ---------------------- Public API ----------------------

    // Pill only (no auto-hide)
    public static void ShowInProgress(string fishName)
    {
        var s = I; if (!s.TryBindUI()) return;
        s.StopAllCoroutines();
        FishWorldVisibility.HideAll();
        s.ui.Show(fishName, HookState.InProgress);
        OverlayShown?.Invoke(HookState.InProgress);
    }

    // Compatibility: force through flash logic with global hold
    public static void ShowCaught(string fishName)  => FlashCaught(fishName, -1f);
    public static void ShowEscaped(string fishName) => FlashEscaped(fishName, -1f);

    // Flash helpers; pass <= 0 to use global defaults
    public static void FlashCaught(string fishName, float seconds = -1f)
    {
        var s = I; if (!s.TryBindUI()) return;
        s.StopAllCoroutines();
        s.ui.Show(fishName, HookState.Caught);
        OverlayShown?.Invoke(HookState.Caught);
        float hold = seconds > 0f ? seconds : CaughtHoldSeconds;
        s.StartCoroutine(s.HideAfter(hold));
    }

    public static void FlashEscaped(string fishName, float seconds = -1f)
    {
        var s = I; if (!s.TryBindUI()) return;
        s.StopAllCoroutines();
        s.ui.Show(fishName, HookState.Escaped);
        OverlayShown?.Invoke(HookState.Escaped);
        float hold = seconds > 0f ? seconds : EscapedHoldSeconds;
        s.StartCoroutine(s.HideAfter(hold));
    }

    public static void Hide()
    {
        var s = I; if (!s.TryBindUI()) return;
        s.StopAllCoroutines();
        s.ui.Hide();
        FishWorldVisibility.ShowAll();
        OverlayHidden?.Invoke();
    }

    private IEnumerator HideAfter(float seconds)
    {
        yield return new WaitForSecondsRealtime(seconds);
        if (ui) ui.Hide();
        FishWorldVisibility.ShowAll();
        OverlayHidden?.Invoke();
    }
}

